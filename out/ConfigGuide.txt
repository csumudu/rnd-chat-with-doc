Configuration Guide for Customer Connect 11

Table of Contents

1. Preface

2. Guide Information

2.1. Audience

2.2. Prerequisite Knowledge

3. Product Overview

3.1. Customer Connect

4. Generic Configuration

4.1. Application Logging Configuration

4.2. Static Parameter Configuration

4.3. Configure Address Serviceability

4.3.1. Configure Service Address Form

4.3.2. Configure Serviceability Address Search Filters

4.4. Script Parameter Configuration

4.5. Icons

4.6. Configuring External Table Names

4.6.1. Configuring for Service Table

4.6.2. Configuring for Customer Table

4.7. Configuring Expansion fields of Payment Table

4.7.1. Example of Applied Transaction Table

4.7.2. Example of Unbilled Transaction Table

4.7.3. Example of Invoice Transaction Table

4.8. Configuring Service Documents Tab

5. Common Configuration

5.1. Security Framework

5.1.1. Object Access Level

5.1.2. List of Tab/Menu Security Access Level

5.1.3. Field Level Security

5.1.4. Action Administration Security

5.2. Multi Language Support

5.2.1. Process Overview and Illustration

5.2.2. Dynamic Active Translations Supported

5.2.3. Configuration for Translation of API Messages

5.2.4. Dynamic Parameter Interpolation

5.2.4.1. Example in Customer Connect Checkout Page

5.2.5. Pluralisation using ICU Message Format

5.2.6. RTL Support

5.2.6.1. Enabling RTL Support

5.3. Introducing Direct Variables

5.3.1. Achieving Control Next: Managing Dependent Dropdowns

5.4. Configuring Reference Data

5.5. Configuring Action Types

5.5.1. Configuring Action Type Attributes

5.5.1.1. Document Support on Actions

5.5.2. Dynamic Data Configuration

5.5.2.1. Configuring Values from an API Response

5.5.2.2. Configuring Inter-Field Dependencies

5.5.3. Mapping Action UI Fields to API Fields

5.5.4. Configuring Action Types in the Case Panel

5.5.5. Configuring Overrides for fields when Creating an Action

5.5.6. Security Permissions for Actions

5.6. Configuring User Profile Case Type Mapping

5.7. Configuring Case/Issue Reopening Restrictions

5.8. Capturing Issue type on Case Closure

5.8.1. Configuration

5.9. Asset Configuration files for Angular GUI

5.10. Configuring Themes

5.11. Raygun Configuration

5.12. PDF Generation Framework

5.13. UoM Conversion

5.13.1. UoM-Conversion.json

5.14. PE Configuration

5.14.1. Customer Maintenance Issue Creation and Update

5.14.2. Customer Maintenance Issue for Customer Attributes/Lists and Contact Lists

5.14.2.1. Capturing Updates for Additional Lists

5.14.3. Contact Email Verification

5.14.4. Configuring File size for Document Upload

5.14.5. PE Cache Guide for Document Upload

5.14.6. PE Parameter Configuration

5.15. Service Status Change Reason Configuration

5.16. Geographic Address Management Configuration

6. Customer Configuration

6.1. Configuring Payment Methods

6.1.1. Configuring Payment Methods DA Tables

6.1.1.1. Payment Method Validation Expression

6.1.2. Configuring Payment Method Security Access

6.1.3. Configuring Others Payment Method

6.1.4. Configuring Payment Type Filter

6.1.5. Overriding Stored Payment Methods

6.2. Configuring Customer Status Change Reason

6.3. Configuring Global Search Filters

6.4. Configuring Account

6.4.1. Account Actions

6.4.2. Account Classification

6.4.3. Balance Transfer

6.4.4. Aged Debt Classification

6.5. Configuring Order Reason Codes

6.5.1. Reason for Maintenance Codes

6.5.1.1. Complex Orders and Default Values

6.5.1.2. Sample Reason Code Configuration

6.5.2. Reason for Cancellation Codes

6.5.2.1. Complex Orders and Default Values

6.5.3. Removing Reason Codes

6.5.4. Reason to Advance Collection Process to another Treatment Steps

6.5.5. Reason for Equipment Swap

6.5.6. Updating the Payment Arrangement Instalment Due Date or Instalment Amount

6.6. Capture Consent Configuration

6.7. Adjustment Type Reason Mapping Configuration

6.8. Managing Disputes

6.8.1. Configuring Dispute Resolve Definition

6.8.2. Invoice Language

6.8.3. Invoice Address Choice

6.8.4. Resend Invoice Link

6.9. Dispute Adjustment Reason Mapping Configuration

6.10. External Applications: Contextual URL Invocation for Customer, Case, and Contact Management

6.10.1. Structure of the URL

6.10.1.1. Configuring Optional Parameters

6.10.2. Example for URL

6.10.3. Functionality Overview: Supported Utilities and Search Keys

6.10.4. Redirecting Behaviors: Rules and Configuring Preferences

6.10.5. Redirection Workflow from CTI Application: Conceptual Diagram

6.10.6. Redirection Workflow from CTI Application: Sequence Diagram

6.11. Anatomy for Summary of Change Comment Model

6.12. Configuring Notifications for History and Alerts

6.13. Customer and Contact Association Roles

6.14. Essential Payment Consideration for Order Completion

6.15. Steps to Configure Issue Types

6.15.1. Account Adjustment Issue Type Configuration Guidelines

6.15.2. Deposit Transfer to Debtor Account Adjustment Type Configuration Guidelines

6.15.3. Troubleshooting Issue Type Configuration Guidelines

6.15.4. One-off Charge Issue Type Configuration Guidelines

6.15.4.1. Managing Dynamic Amount Fields Based on Service Selection

6.16. Configuring Contract Document Upload During Orders

6.17. Treatment Payment Arrangement Rule

6.18. Configure Billing Settings Forms and Tables

6.19. Customising Customer or Contact Screens

7. Integration Infrastructure Configuration

7.1. API Error Model

7.1.1. API Error Message

7.1.2. API Warning Message

7.1.2.1. Swagger Specifications

7.2. Extensions

7.2.1. iframe Configuration

7.2.2. User Access

7.2.3. Constraints and Limitations

7.3. External Plugins Support

7.3.1. Build Project and Libraries

7.3.2. Setting up Plugin Development Environment

7.3.3. Creating Plugin

7.3.3.1. Adding Plugin Component

7.3.3.2. Add Plugin Module

7.3.3.3. Build Plugin

7.3.4. Accessing Data inside Plugin

7.3.4.1. Angular Module as a Plugin

7.3.4.2. Angular Component as a Plugin

7.3.5. Plugin Configurations

7.3.6. Global Style Overrides

8. Product Configuration

8.1. Operations for Purchased Products

8.2. Configuration of Multiple Product Offers with Same Display Name

9. Configuring Order Task Framework

9.1. Configuration for executing Tasks in Customer Connect

9.2. Different Order Stages

9.3. Meaning of Special Value Types

10. References

Copyright Notice

Release Date

Thursday, 29 August 2024

Document Version Number  v1.0

Software Version Number  v11.28.0

1. Preface

This guide describes Customer Connect configuration details for:

Managing Application using PEREST Adapter

Product Catalogue Management

Adding Performance Cache Setup

Angular GUI Asset Files

Extensions

External Plugin Support

Themes Support

2. Guide Information

This section describes the guide audience and prerequisite knowledge.

2.1. Audience

This guide is aimed at:

Implementation teams that customise business solutions into configurations for customers.

Analysts who are involved in analysing the customer requirements.

CSG International business partners who assist implementation teams in the customisation process.

2.2. Prerequisite Knowledge

This guide assumes that the reader has:

Basic knowledge of Customer Connect.

Basic knowledge of Business & Administration Studio

3. Product Overview

This section describes Encompass products included in this guide.

3.1. Customer Connect

Customer Connect provides a consistent, accurate, and complete view of customer data across the enterprise. It also provides a fast and intuitive solution to manage customer communication, order management, customer analysis and reporting, query resolution, troubleshooting, billing management, and product management.

4. Generic Configuration

4.1. Application Logging Configuration

The application supports log management by collecting and publishing application logs to various log publishers. To customise this behavior, modify the global configuration settings. The path to access the file is /assets/config/app-log.config.json.

Adjust the properties within this JSON file to configure how logs are collected and where they are published. Specify different log publishers and set parameters according to the requirements.

For users with the appropriate menu-level security permissions, there is an option to override these global configurations. This can be done by navigating to the Settings section within the CSR Toolbox, where the properties can be adjusted to meet specific needs.

Parameter Configuration Description Example logLevel Value of the Log level property determines the level of information being logged by the Customer Connect. Possible values are listed below: OFF FATEL ERROR WARN INFO DEBUG ALL By default, the logLevel is set to OFF, which means no logging occurs. When a log level is selected, it will activate logging for that level and all levels with higher verbosity. For example, if INFO is selected, it will record and send logs at the following levels to the publisher: INFO WARN ERROR FATAL This setup ensures that more detailed log information is captured as you choose higher log levels. logLevel":"DEBUG logLevelByContext The log level can be configured for specific modules by assigning appropriate log levels to each module. While the global logLevel property sets a default log level for each module, it can be overridden by specifying a higher log level value. This allows for more granular control of logging based on the needs of individual modules. "logLevelByContext": { "APPLICATION": "DEBUG", "NGRX_STORE_INFO": "INFO", "HTTP_SERVICE": "ERROR" } logPublishers The logPublishers array supports multiple values, allowing to configure various log publishers. The available options include: CONSOLE: Web Browser Console WEB_API: External Web API Endpoint WEB_SOCLET: External Web Socket Endpoint LOCAL_STROAGE: Browser Local Storage Include one or more of these publishers in the array to suit logging requirements. Note WEB_API and WEB_SOCKET publishers required endpoints to be configured in /assets/config/statis.config.json file. For more details, see Static Parameter Configuration . "logPublisher": ["CONSOLE","WEB_API]

4.2. Static Parameter Configuration

The static parameter configuration will affect all the users (sessions) logged in to the application. All the recommended static configurations are stored in static.config.json file. The path to access the file is ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

Parameter Configuration Description configSenderEmail In order to send emails from the application, the sender email address must be configured. Note An error message will be displayed if the sender’s email address is not configured. "getAllUsersRetrievalLimit": 100, Used to retrieve the users as per the set limit. "idleLogoutTime": 600000 The ideal logout time of the application is set in milliseconds using this parameter. "loginFooterContent": { "title": "Need Help with your account?", "items": [ { "label": "", "image": "./assets/images/email/Icons_01 _ Outline_Tools _ Technology _ email .png", "value": "support@xyz.com" }, { "label": "", "image": "./assets/images/materialIcons/phone-plus/phone-gray.svg", "value": "+00 0000 000" } ] } The title is displayed on the login page of the Customer Connect application. Support email id value can be updated. Support phone number value can be updated. "fieldsToBeHidden": { "workAddress": false } Work address for contact. "offers": { "catalogSearchFilterEnabled": false, "includeInitialChildOffer": false, "labels": { "configCustomerId": "CUSTOMER ID: ", "configContactId": "CONTACT ID: " }, "pageSize": 12, "exploreCatalog": { "enabled": true, "order": -1, "pageSize": 12, "title": "Explore" } } catalogSearchFilterEnabled : Set true to enable the filtering of catalogs in the offering listing page. pageSize : Default page size of the offer modules. exploreCatalog : Used to find offers (top-level offers or child offers) in the catalog by applying preset filters. enabled : Set true to enable the exploreCatalog in the Offers tab. Set false to disable the exploreCatalog in the Offers tab. order : Used to set the order of catalog displayed on the screen. For example, -1 indicates the first entry, and 1 indicates the last entry. pageSize : Page size of the explore catalog. Used to configure the minimum number of offers that need to be loaded after filters are applied. includeInitialChildOffer : The parameter is set true; to process CLOs which are initially included to show their details on offer listing cards. Note The page size set here overrides the default page size. title : used to set the name of the tab. Note The explore catalog configurations will also apply for the change plan screen. "derivedAttributeTagsTable": { "customer": { "tableName": "Customer.daTags", "fieldName": "tags", "valueType": "RT-CUSTOMER_DYNAMIC_TAG" }, "contact": { "tableName": "Contact.daTags", "fieldName": "tag", "valueType": "RT-CONTACT_DYNAMIC_TAG" } } It contains the Tags which displays in the UI based on the entity table name and valueType. "paymentConsideration": { "useExternalAdviceOfCharge": false, "useExternalNegotiatedAdviceOfCharge": true, "includeUpfrontAmountInAOC": true, "AdviceOfChargePriceTypeColumnAssignment": { "Upfront": [ "Upfront", "Discount" ], "Deposit": [ "Deposit" ], "Recurring": [ "Recurring", "RealTimePeriodic", "Installment" ] }, "salesOrder": { "offerPriceTypes": [ "Upfront", "Deposit" ], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "modifyOffer": { "offerPriceTypes": [ "Upfront", "Deposit" ], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "addChildOffer": { "offerPriceTypes": [ "Upfront", "Deposit" ], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "changePlan": { "offerPriceTypes": [ "Upfront", "Deposit" ], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "removeChildOffer": { "offerPriceTypes": [], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "simChange": { "offerPriceTypes": [], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "msisdnChange": { "offerPriceTypes": [], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "terminateSubscription": { "offerPriceTypes": [], "adviceOfChargePriceTypes": [ "Upfront", "Discount" ], "enableAdviceOfCharge": true }, "renewOffer": { "offerPriceTypes": [ "RealTimePeriodic" ] } } This configuration is used to determine the price types eligible for immediate payments for various flows. It also enables external "Advice of Charge" and "Negotiated Advice of Charge" functionality. For more information, see Essential Payment Consideration for Order Completion . "orderConfigurations": { "changePlan": { "negotiationAllowedPriceTypesForCarriedOver": [] } }, This configuration is used to configure price types that can be negotiated or overridden for carried-over offers on the change plan configuration page. If the same price type is provided here and in paymentConsideration.changePlan.offerPriceTypes it will be disabled (paymentConsideration takes precedence). "enablePaymentReceiptViewer": false Used this parameter to configure the payment receipt toggle button to show the receipt after the checkout process. { "purchasedProduct": { "nonCancelledPurchasedProduct": { "limit": 9999 }, "cancelledPurchasedProduct": { "limit": 100 }, "serviceTypeIcons": { "1081500": { "iconType": "name", "iconName": "augmented_reality" }, "374001": { "iconType": "name", "iconName": "mobile_prepaid" }, "138701": { "iconType": "name", "iconName": "mobile_postpaid" } } } } Configures rows per page limit for each purchased product menu. Recommended configuration: For nonCancelledPurchasedProduct: limit = 9999 For cancelledPurchasedProduct: limit = 100 Note It can be defined based on the requirements. Configure iconName to use for each service type. "enableSavedPaymentMethod": false enableSavedPaymentMethod - Set true to enable the Saved Payment Method section in the Billing settings tab. Set false to disable the Saved Payment Method section in the Billing settings tab. "referenceDataConfig": { "sortField": "name", "sortOrder": "ASC" sortField - Used to sort the reference data like name, value, childRef, childRefId, and type. sortOrder - Used to decide the sorting order. ASC is used for ascending order and DESC for descending order. "maximumDate": "31 Dec 9999 23:59:59", maximumDate is backend max date (oracle max date). It is used to indicate the end date for a query search. "mobileNumberPortability": false, mobileNumberPortability - Set true to enable the Port Number tab in the SIM Options widget (Configuration page). Set false to disable the Port Number tab in the SIM Options widget. "isCollectionsEnabled": false, isCollectionsEnabled - Set true to enable the Collections feature. Set false to disable the Collections feature. "contactRolesForCaseClosure": [] contactRolesForCaseClosure - It can contain a list of contact roles. When replacing a customer’s primary contact, if the role chosen for the new primary contact is present in this list, it will close the current case. "serverTimezone": "UTC" Mandatory. It is the time zone of the SV server machine. A valid IANA time zone must be specified, for example: "serverTimezone": “America/Jamaica” "vatType": "Personal", "companyVatType": "Corporate", vatType - Used to set the default field value (VAT Type) during consumer customer creation. companyVatType - Used to set the default field value (VAT Type) during corporate customer creation. "dynamicExportSettings": { "exportDaysLimit": 30, "usageExportSettings": [ { "dynamicProp": "usageChargeCharacteristic", "titleProp": "name", "valueProps": ["value", "unit"], "skipFields": ["Event Sub Type"] } ] }, dynamicExportSettings - Used to configure the export to CSV button in the Usage tab. "exportDaysLimit": 30, - Export limit of 30 days (data). Note By updating the numbers, the days can be extended. "dynamicProp": "usageChargeCharacteristic", - Data object property to be examined. "titleProp": "name", - CSV header title value, the code takes the 'name' property value from within the 'usageChargeCharacteristic. "valueProps": ["value", "unit"], - The values to extract (extracting 'value' and 'unit' values) for each column. "skipFields": ["Event Sub Type"] - Skips this 'titleProp' value and do not export it. "applicationLoginBgImageUrl" Used this parameter to configure a background image for the application login page. Add a photo to the address location “assets>images”. Example value for the parameter: assets/image/bg-img2.jpg. Note Image size should be less than or equal to 200 kb with dimensions less than or equal to “1900 x 1080”. "sourceName" Cases created via customer connect will have the default case source of "CC-Incoming Phone", defined using the parameter sourceName. Projects can change this default value and map it to data in 'How_Received' PE class. "genericConfigFileName" Used to configure the user to mention the required Configuration file as per need, so NGUI will load the same Configuration file and render the contact and customer screen. Configuration file going to be picked from the asset/config folder. "isNextBestActionOfferEnabled" This is a toggle button for use this parameter to configure turning ON/OFF the best action offer details. "simOptionsConfiguration": { "reservedNumber": true, "reservedNumberLabel": "Reserved Number", "selectedNumber": true, "selectNumberLabel": "Select Number", "redeemNumber": true, "redeemNumberLabel": "Redeem Number" } simOptionsConfiguration : This configuration is used to configure the option to enable and disable different SIM options tabs and rename them if required. reservedNumber : If it is set to true, the user can enable the reserved number tab by setting its value. reservedNumber : If it is set to false, the user can disable the tab and it would not show up in the SIM options. The user can also rename the reserved number tab by changing the value of reservedNumberLabel . Note The same operations can be done for all the tabs in the SIM options in the configuration. "scrollingBanner": { "isScrollingBannerVisible": true, "isScrollingBannerEnabled": true, "scrollingDirection":"rtl" }, isScrollingBannerVisible : “true” - The parameter is set to true; the user can see scrolling banner messages and banner icon in the screen’s header across the application wherever a Global search is displayed. isScrollingBannerEnabled : "true" - The parameter is set to true; indicating that the scrolling banner messages are expanded when CSR login into the application. scrollingDirection : This configuration is used to configure the scrolling banner message direction. Note scrollingDirection : "rtl": The direction of the scrolling banner message should be read from right to left. scrollingDirection : "ltr": The direction of the scrolling banner message should be read from left to right. "projectConfig": { "checkout": { "AdditionalInfo": "mandatory", "hasVatId": true, "hasVatCompanyName": true, "prepaidAccountBalanceEnabled": true, "isPaymentReceiptConsolidated": false } }, AdditionalInfo : It has possible values of mandatory and optional . mandatory : To make the Vat type drop-down mandatory and the Vat ID textbox visible and mandatory when the Vat type is selected as corporate. optional : To make the Vat type drop-down optional and the Vat ID textbox hidden for all Vat type selections. hasVatId : Set to true to show the Vat ID provided Vat Type selected as Corporate and AdditionalInfo is mandatory . hasVatCompanyName : Set to true to show the Vat Company Name provided Vat Type selected as Corporate and AdditionalInfo is mandatory . "voucherDischarge": { "requireSerialNumberForDamagedPin": true } This is a toggle button for using this parameter to configure turning to allow/prevent check against damaged PIN value (Examples: 123??678, 123??ABC…​ etc) A damaged PIN is a PIN that contains non-alphanumeric values. The Customer Connect logic can handle any non-alphanumeric value for wildcard, currently the specific wildcard value is the '?' character. When the PIN has a value with '?' the Redeem button will stay disabled. requireSerialNumberForDamagedPin : Set true, If the PIN is damaged, Redeem button will be disabled. Note Redeem button will be enabled if the PIN is alpha-numeric (not-damaged) or damaged but the Serial Number is also non-empty. "outboundAPI": { "errorNotification": "externalOutbound?apiname=errorNotification" } errorNotification : It specifies the endpoint used to trigger API call to check error or warnings before cancelling or changing a service. "prospectEnquiry": { "runEligibilityOnCustomerSelection": true } runEligibilityOnCustomerSelection : Used to determine whether to conduct eligibility checks for selected offers and its associated catalog eligibility following customer selection on the Order Config page. “isDataErasureEnabled”: true Used to toggle the visibility of Personal Data Erasure rack under Contact Setting tab. isDataErasureEnabled : Set true to show the Personal Data Erasure rack under Contact Setting tab. Set false to hide the Personal Data Erasure rack under Contact Setting tab. "listViewSettings": { "showTaxRegistrationList": true, "preferredCommunicationsList": true }, "contactSettingsRackOrder": [ "PREFERRED_COMMUNICATIONS_LIST", "COMMUNICATION_ALERTS", "COMMUNICATION_SCHEDULE", "PREFERRED_STORES", "CONSENT_QUESTIONS", "PERSONAL_DATA_ERASURE" ], The communication preference list is placed under the Contact, Settings screen. The communication preference list is toggled with the preferredCommunicationsList property in the listViewSettings configuration. Each constant represents one rack on the UI, and in order to show the communication preference list both places need to be configured: Set the preferredCommunicationsList to true. Insert the PREFERRED_COMMUNICATIONS_LIST constant in the contactSettingsRackOrder array. contactSettingsRackOrder list is used to configure the order of the racks. "allowedValidationsTypes": [Contact field,Fingerprint, and OTP validation] Contact field : Users will have the capability to show and hide information validation check box in the prospect panel UI if the configuration type is available. Fingerprint : Users will have the capability to show and hide fingerprint validation in the prospect panel UI if the configuration type is available. OTP validation : Users will have the capability to show and hide OTP validation in the prospect panel UI if the configuration type is available. Note If a validation method is missing in the allowedValidations then, it will not appear on the UI. If the allowedValidations is empty, then the contact panel is skipped entirely and landed in the Contact/Customer overview. "otpValidationConfig": { "retryTimeLimit": 90, "otpLength": 4, "retryLimit": 3 } The timer for the OTP validation popup can be configured only in seconds by modifying the retryTimeLimit in the otpValidationConfig object. This timer is to enable or disable the resend button based on the time left. The length of the OTP can be modified through the otpLength property in the otpValidationConfig object. This should not be configured to less than 4 and more than 8 for the best user experience. The otpLength also need to be in sync with the backend so that the received OTP is also of the same length. retryLimit : The generate OTP button should have a configurable count (Example: specifying how many times a user can click on the generate button). showResetIcon Set to true to enable the visibility of resetIcon in the otpValidation pop-up. Set to false to disable the visibility of resetIcon in the otpValidation pop-up. showQuitCasePopup Set to true to enable the visibility of quitCasepopup in the associated-customer Tab. Set to false to enable the visibility of roaster message in the associated customer Tab. openCustomerValidationPanel Set to true to enable the visibility of validationPanel in the associated customer Tab, when navigating to another customer. Set to false to disable the visibility of any validationPanel, allowing direct navigation to the customer overview page. "appointmentCalendarOptions": { "startTime": <Time in 24H format>, "endTime": <Time in 24H format>, "interval": <Interval Value in Minutes> } Installation Appointment Calendar is available under the installation tab which is available during the order checkout if the order is eligible for installation. startTime Defines the start time used to create the Calendar Grid Should specify in 24 Hour format Value should be less than "endTime" endTime Defines the end time used to create the Calendar Grid Should specify in 24 Hour format Value should be greater than "startTime" interval Time interval used to create slots between start time and end time Should specify in Minutes Should be a positive integer Interval value should be less than or equal to time duration between start time and end time Example Configuration "appointmentCalendarOptions": { "startTime": "08:00", "endTime": "22:30", "interval": 30 } "contactValidationConfiguration": { "contactPropertyList": [ { "propName": "legalName", "displayName": "Contact Name" }, { "propName": "nationality", "displayName": "Nationality" }, { "propName": "birthDate", "displayName": "Date of Birth" }, { "propName": "defaultEmailAddress", "displayName": "Email Address" }, { "propName": "contactStatus", "displayName": "Contact Status" } ] }, contactValidationConfiguration : This configuration is used to configure the contact validation settings. Note If the field is already rendered on contact-information screen then the propName should be the stateKey of that field in dynamic-forms.config.json . If the field is not supposed to be rendered on contact-information screen then need to specify conversion from API data to state data after mentioning the conversion at contactInformation → NoTab → noForm of dynamic-forms.config.json and propName will be the stateKey. contactPropertyList : This parameter specifies a list of attributes that can be validated from the contact panel. If no attributes are configured, the panel will display only the National ID and Contact Name fields. propName : Property specifies the name of the attribute property, while the displayName property is used to label the attribute. "customerServices":{ "listOfCancelStatusTypes": ["Cancelled", "Cancellation Required", "Inactive"], "toPerformCancelStatus": "Cancellation Required", "cancelService": { "enableQuoteAPI": true, "enableErrorNotification": true } , "serviceReadOnlyStatus": ["Cancelled", "Cancellation Required"], "enableDeviceReplacement": true, "unlimitedEntitlementPatterns": ["999999999"], "enableRenewoffer": true, "modifyOfferCancellationReason": "Change Offer", "excludedB2BTypes": [] }, listOfCancelStatusTypes : Configures the status code that can be considered as cancelled status. toPerformCancelStatus : Configures cancel status used for cancelling. enableErrorNotification : Setting it to true will trigger an API before cancelling or changing service to check for errors or warnings. serviceReadOnlyStatus : Configures the status code that can be considered when showing instances in read-only mode. enableDeviceReplacement : Enable or Disable device replacement capability. unlimitedEntitlementPatterns : List of entitlement allocation value patterns to consider as unlimited allocations. By default "999999999" will be considered as unlimited value. enableRenewOffer : Set true to enable the Renew Now functionality under customer service. Set false to disable the Renew Now functionality (the whole feature will be disabled), and there will be no renewOffer API call fired to the backend. modifyOfferCancellationReason : The order cancellation reason that should be used for creating an Alter Product Order from the Modify Offer flow in the application. excludedB2BTypes : Specify B2B customer types whose purchased products will be shown in B2C way which is without grouping purchased plans by catalog. searchSIMwithIMSI searchSIMwithIMSI : Set true to show label as IMSI under SIM Details tab. Set false to show label as ICCID under SIM Details tab. isSponserNumberOptional This configuration field determines whether the Sponsor Number is optional or mandatory to enable the Get Offer button in the redeem coupon code popup. isSponserNumberOptional : Set true to make the Sponsor Number an optional field. Set false to make the Sponsor Number a mandatory field. enableFetchAdviceOfCharge Used to enable the newly added fetch advice of charge API that fetches the saved advice of charge prices which were stored during the submission. This value is configured as true by default, but it can be configured as false, which will disable the new fetch API. defaultCountryCode Used this parameter to achieve the functionality having a common default country selected for all the MSISDN fields. The country code assigned to the key defaultCountryCode is as per ISO-3166 Alpha-2 code format. For more information on Country codes, see Online Browsing Platform (OBP) . "showCaseType": boolean showCaseType : Set true to show case type in tables (Recent Cases, CSR Cases, Customer Cases & Contact Cases) under Case Id column and Case Panel (collapsed and expanded) will show header icon in header and when hovered the tooltip will show case type. Set false to hide the visibility. "enableAdditionalUsageFilter": true enableAdditionalUsageFilter : This parameter is to enable the display of additional usage filters i.e. Is Billed and Amount , and to allow the Event Types filter to support the selection of multiple event types. "enableReopenCaseAndIssue": true enableReopenCaseAndIssue : This parameter is to configure the below functionalities: Enable or disable the Reopen Case button in the Viewing case panel. Adding a Reopen Issue action button on the Viewing Issue, Close Panel, and Open Panel. "enableDisputesDatePickerFilter": true enableDisputesDatePickerFilter : Set true to display the date picker in the filters section of the disputes tab and allow filtering of the disputes based on the selected date picker value in the Billing Disputes tab. Set false to disable the above functionalities in the Billing Disputes tab. "enableEnhancedContractPresentation": true enableEnhancedContractPresentation : This parameter enables the following for offers that have a Contract feature: More contract details and a Go to Document button should be displayed in the Contract rack at TLO. When expand an offer, there will be a Contract section containing the contract details and a Go to Document button. usageUnbilledCurrencyDecimalLimit usageUnbilledCurrencyDecimalLimit : This parameter configures the number of decimal places displayed in the UI for usage and unbilled charges. This can be different to the number of decimal places supported by the currency, as individual usage charges may use high-precision rates that are aggregated within an invoice. It does not impact the number of decimal places for values entered by a CSR, these must always confirm to the decimal places supported by the currency in use. It does effect on download or export CSV file on usage charges (amount column) screen, as it reads amount decimal place from this configured parameter. contactLandingTab If the value entered is overview , it will navigate to the contact overview tab, and it is not security controllable. If the value entered is settings , it will navigate to the contact settings tab only if there is security access. If the value entered is documents , it will navigate to the contact documents tab only if there is security access. If the value entered is associatedCustomers , it will navigate to the contact associatedCustomers tab only if there is security access. If the value entered is additionalInfo , it will navigate to the contact additionalInfo tab only if there is security access, and in the static file, the isAdditionalInfoTabEnabled property should be true. If the contactLandingTab is empty, given an incorrect value (i.e., any tab value other than the mentioned ones), the property is not present in the static file, or for any of the given five tabs, security access is set to no-access, it will fall back to the overview tab. "paymentLocation": { "default": "Bank", "voucher": "Customer Via Web" } paymentLocation : This parameter defines the value populated by the UI in the Channel field while making a payment. This value is stored as the location field of a payment. Payments made using a voucher can be configured separately to other payment types. enableCustomerHierarchyPagination This parameter enables pagination behavior when fetching customer hierarchy data from the server. Set false , then the entire customer hierarchy is fetched and presented on the screen. Set true , then the initial customer hierarchy data fetch will retrieve the current node, it’s immediate child nodes, and all immediate parent nodes in a chain back-up to the root customer node. Further customer hierarchy detail can then be fetched by selecting the "see more" option under any of the other nodes of the hierarchy that identifies more information is available and fetches 10 nodes at a time. By default, this flag is set to true. "country": "India", country : Used to set default country. "terminationPriceType": ["Contract Penalty", "Contract ETF"] terminationPriceType : This parameter defines the list of possible price type for contract termination charges. When there is new price type introduced for contract termination charges, it must be added to this list. filteringWithSource filteringWithSource : Enabling this parameter by setting it to 'true' allows users to filter orders and cases by their source. Conversely, setting it to 'false' will hide the filtering option, restricting the utilisation of source-based filters. enableActionItemsSecurity This parameter enable or disable security based control for Acton items in case panel for action creation. Set true , the action types presented for manual creation within the case panel Action will be derived from the DA Profile Action Type , for more information, see Configuring Action Types in the Case Panel . Set false , the action types available to be manually created will be based on all action types available within the system regardless of security profile. “isPasswordResetEnabled”: false, isPasswordResetEnabled : Set true to enable password reset feature on login page. Once isPasswordResetEnabled is set to true, a link Forgot Password will appear on login page. "setDefaultUserForAction": true If this flag is enabled, the logged-in user will be automatically selected in the user drop-down in the create action flow if that user is present in the workgroup that has been selected. By default, this flag is set to false. orderTaskFlow Used to enable the Order Entry Task framework. Set true to enable the Order Task Framework, and false to disable it. This framework configures aspects of the Order workflow such that the steps of an order can be configured to behave in the way required for the Product Catalog in use. For more information on framework, see Configuring Order Task Framework . "issueTypes": { "issueCreationSequenceList": [ "Dispute", "Troubleshooting", "Account Adjustment", "Customer Service", "Voucher Discharge", "One-off Charge", "Change Ownership - Friendly", "Core Reason" ] } This specifies the order in which issue types will be presented in the case panel during issue creation. If certain issue types are not defined in this list, they will be appended after the defined issue types. "defaultDateRangeForCustHistory": 12 The default date range for the customer action history is set using this parameter. This tab loads and retrieves the data within the default range if no date range is selected by the user. If it is set to zero, there will be no default range. Note The default range should be specified in months. defaultDaysForDepositsView The default date range for the Deposits tab in customer billing is set using this parameter. This tab loads and retrieves data within the selected default range. It is also set as the default date range on the date filter. "documentConfigurations": { "showShareViaEmail":<boolean> } Example: "documentConfigurations": { "showShareViaEmail":false } documentConfigurations : Used to configure Customer Connect documents related to user interfaces. showShareViaEmail : This boolean property can be used to toggle the visibility of the "Share via Email" row actions in the documents table. If no configurations provided or if set to true, the "Share via Email" action icon will be visible. If set to false , the "Share via Email" action icon can be hidden. serviceabilityFunctionality Set true to enable the serviceability functionality. Set false to disable the serviceability functionality. "applicationLoggingConfigurations": { "logPublishingWebApiUrl": "string", "logPublishingWebSocketUrl": "string", "webApiBatchSize": number, "webSocketBatchSize": number, "dataMaskingConfig": { "isDataMaskingEnable": boolean, "maskingFields": string[], "maskingCharacter": "character" } }, The applicationLoggingConfigurations section manages the logging settings for the Customer Connect application. Below are the key properties and their functions: logPublishingWebApiUrl Default: empty string It specifies the Web API endpoint to which Customer Connect logs are sent. When an endpoint URL is set and the WEB_API log publisher is selected, the application will periodically call the specified URL to push logs in batches. logPublishingWebSocketUrl Default: empty string It accepts a WebSocket API endpoint for pushing logs. When an endpoint URL is set and the WEB_SOCKET log publisher is selected, the application will periodically call the specified URL to send logs in batches. webApiBatchSize Default: 50 This numeric value determines the batch size for logs when using the WEB_API publisher. webSocketBatchSize Default: 25 This numeric value sets the batch size for logs when using the WEB_SOCKET publisher. dataMaskingConfig This contains settings for log entry masking, which is useful for concealing sensitive information before logs are sent to publishers. isDataMaskingEnabled Default: false It determines whether log masking is enabled when logs are pushed to publishers. maskingFields Default: empty array It holds an array of field names whose values should be masked before being sent to log publishers. maskingCharacter Default: 'x' This character is used for masking sensitive data fields. If no specific character is defined, the default masking character 'x' will be used. These settings enable fine-tuning of the logging behavior for the Customer Connect application to meet specific requirements. Example: "applicationLoggingConfigurations": { "logPublishingWebApiUrl": "http://log.publisher/api/publish", "logPublishingWebSocketUrl": "ws://log.publisher/ws", "webApiBatchSize": 50, "webSocketBatchSize": 25, "dataMaskingConfig": { "isDataMaskingEnable": false, "maskingFields": ["email", "creditCard", "password", "number", "fax"], "maskingCharacter": "x" } }, reasonCodeFilterName To mark a filter for special handling when filtering offers based on reason codes in the Order configuration page. The display name of the filter is configured here. wsKeepAliveInterval": 20000 Used to set time interval for the web socket connection to be active. If connection does not receive any message from server in three times of keepAliveInterval then it closes the connection. "wsConnectProtocol": ["EventNotify"] Used to set web socket connection protocol which PEREST adapter expects. "msisdnResourceType": "MSISDN" It provides information on msisdn resource type. "simCardResourceType": "SIM Card" It provides information on SIM card resource type. "externalReserverType": "CouponCode" It provides information on external resource type. "fingerPrintDeviceAvailable": true fingerPrintDeviceAvailable : Set true to make finger print device available, and false to unavailable it. "paymentRefStatus": { "paymentPaidStatus": ["Applied", "Entered", "Future Dated"] } paymentRefStatus : Used to store information related to payment status. paymentPaidStatus : Contains the paid status list. Any payment status which is part of this list will be considered paid. "project": "Customer Connect" Project field is used to Toast project name only in development mode. "redeemCouponCodeFunctionality": true redeemCouponCodeFunctionality : Set true to make coupon code redeem functionality available, and false to unavailable it. "showOrderSpecificationComponent": false showOrderSpecificationComponent : Set true to show the order specification component on order configuration page, and false to hide it. "showActiveSubscriptionWarningDialog" : true showActiveSubscriptionWarningDialog : Used to show and hide the active subscription warning dialog box which pops up on clicking button Confirm Proceed to Configuration on offer listing page. Set true to show the active subscription warning dialog box, and false to hide it. "showCugToggleFunctionality": false showCugToggleFunctionality : Set true to show the the CUG Toggle functionality on ToolBar menu, and false to hide it. "usageDataLimitInDays": 0 usageDataLimitInDays sets value for usage data limit. "customerBilling": { "appliedTransactionsNoDays": 7; "defaultInvoiceFormat": '""; } customerBilling section has below fields: appliedTransactionsNoDays : Used to set the default period for extracting the Applied transactions. defaultInvoiceFormat : Used to set the default invoice format in invoice formats table section in customer billing setting. "prepaidAccountBalanceEnabled": true prepaidAccountBalanceEnabled: Set true to show the prepaid section in payment, and false to hide it. "isPaymentReceiptConsolidated" : true isPaymentReceiptConsolidated : Used to configurable consolidated or individual payment receipts when multiple payment methods are used for payment. It is used to print or email payment receipt after successful payment. Set true to consolidate payment receipt, and false for individual payment receipts. "nationality": "Mongolian" The nationality field value is used to add nationality to contact during contact creation or update. It is added only when the contact has a national ID. "enableSummaryOfChangeWidgetData": true enableSummaryOfChangeWidgetData : Set true to configure the summary of change widget data on customer service overview page. "ordersStatuses": ["Open", "Closed", "Submit"] ordersStatuses : Used in creating order status filter list for order listing page. This list contains order statuses which will not be part of order status filter. "mobileNumberPortabilityPortIn": true mobileNumberPortabilityPortIn : Set true to enable the PortNumber tab in the SIM options widget (Configuration screen). "invoiceOverpaymentAllowed": true invoiceOverpaymentAllowed : Used to allow or deny the over payment of invoice. "showReUseReasonInSales": true showReUseReasonInSales : Set true to show reuse reason drop-down in SIM details section in sales, and false to hide it. "isAdditionalInfoTabEnabled" : true isAdditionalInfoTabEnabled : Set true to show contact’s Additional Info tab, and false to hide it. "isSyncContactInfoWithNationalDBIconBtnEnabled" : true isSyncContactInfoWithNationalDBIconBtnEnabled : Set true to show Sync Contact Information with National DB icon, and false to hide it. "isCommunicationAlertComponentEnabled": true isCommunicationAlertComponentEnabled : Used to determine if Communication & Alerts component is enabled or disabled. Set true to show Communication & Alerts rack on Contact Information settings page, and false to hide it. "isPreferredStoredComponentEnabled": true isPreferredStoredComponentEnabled : Set true to show preferred stores rack on Contact Information Setting page, and false to hide it. "isDateErasureEnabled": true isDateErasureEnabled : Set true to show Data Erasure rack on UI, and false to hide it. "isReadBillFromUrl" : true isReadBillFromUrl : Set true to exclude the Customer Bill API to download the file content in response and just return the URL on customer billing overview and invoice tab page. "enableCustomerHierarachyPagination": true This parameter enables pagination behavior when fetching customer hierarchy data from the server. Set false , then the entire customer hierarchy is fetched and presented on the screen. Set true , then the initial customer hierarchy data fetch will retrieve the current node, it is immediate child nodes, and all immediate parent nodes in a chain back-up to the root customer node. Further customer hierarchy detail can then be fetched by selecting the "see more" option under any of the other nodes of the hierarchy that identifies more information is available and fetches 10 nodes at a time. By default, this flag is set to true. "usageUnbilledCurrenyDecimalLimit": 2 usageUnbilledCurrenyDecimalLimit : This parameter is to set the decimal limit for usage and unbilled charges amount. Default value is 2 and maximum value is 6. "defaultDaysForPaymentView": 30 defaultDaysForPaymentView : Used to set default number of days to view payment records.

4.3. Configure Address Serviceability

Address Serviceability can be configured using the configuration file serviceability-confg.json available in Customer connect at <CC-Root>/assets/config/serviceability.config.json.

Changes to the configuration will affect all the users (sessions) logged into the Customer Connect.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

Update config properties as required. Refer to the following table for more information:

Property Description Example addressAvailableNetworkStatusCodes Used to set the serviceable address network status code. None defaultUnavailabilityReason Used to set the message for the offers that will not be available due to serviceability. None serviceabilityAddressType Used to set the serviceable address type. None isInstallationReqByDefault Used to enable toggle (Is installation required?) button. Setting false will disable the toggle button. None addressSearchInitiationCharacterLimit Used to set the address search character limit as a configurable static field. Note If addressSearchInitiationCharacterLimit is set to zero, then any letter entered in the input field will initiate a search, similar to limit one. None fieldsRequiredServicabiltyCheck Used to define the fields which require serviceability check. Fields added in this array will be non-editable while updating the Service Address during sales order and update order. None serviceabilityType Used to set the serviceability address search type. It can be either product or google or custom . When this property is set as product serviceability form comes with dynamic filters. When this property is set as google serviceability form comes with Google search. When this property is set as custom serviceability form comes custom search with three fixed fields namely City , District , and Subdistrict . None isAddressValidationRequired If Address validation is required for Google’s suggested address before performing a serviceability check, set isAddressValidationRequired to true. None serviceabilityApiToGeographicAddressMap This property is used to control address conversions. This can have product , google , and custom as child properties (one or more) which will be used to set the configuration to a particular serviceability form. "serviceabilityApiToGeographicAddressMap": { "custom": { "toGeographicAddress": { "country": "country", "suburb": "subDistrict", "city": "city", "stateOrProvince": "district", "buildingId": "buildingId", "geocode": "what3WordLocation", "region": "regionName" }, "toProductOfferQueryParam": { "addressId": "buildingId", "cityId": "cityId", "districtId": "districtId", "subDistrictId": "subDistrictId" }, "addressFieldsDisplayOrder": ["buildingName", "subDistrict", "district", "city"] } } toGeographicAddress Used to convert address from service address format to GeographicAddress format. "toGeographicAddress": { "city": "city", "country": "country", "suburb": "suburb", "postCode": "postCode", "stateOrProvince": "stateOrProvince", "street1": "street1", "street2": "street2", "geocode": "geocode", "addressLine1": "addressLine1", "buildingId": "buildingId", "subDoorNumber": "subDoorNumber", "genericAddress": "genericAddress", "region": "region", "xpos": "xpos", "ypos": "ypos" }, Following are the fields supported which can be read from /geographicAddress api : city, country, suburb, postcode, stateOrProvince, street1, street2, geocode, addressLine1, building, buildingId, subDoorNumber, genericAddress, xpos, ypos and region. toProductOfferQueryParam Used to define the address query params to be sent in /productOffering api using /geographicAddress api . Following are the fields supported which can be read from /geographicAddress api : addressId, city, cityId, country, countryId, suburb, suburbId, postcode, postcodeId, stateOrProvince, stateOrProvinceId, street1, street1Id, street2, street2Id, geocode, geocodeId, addressLine1, addressLine1Id, building, buildingId, subDoorNumber, subDoorNumberId, genericAddress, genericAddressId, region, regionId, xpos, and ypos. addressFieldsDisplayOrder Used to set the order of address fields in address list in serviceability address form. "addressFieldsDisplayOrder": ["buildingName", "subDistrict", "district", "city"] widgetConfig Pass parameters to Google Place API. For more information about all possible value, see AutocompletionRequest interface . "widgetConfig": { "componentRestrictions": { "country": [] }, "fields": ["address_components", "geometry"], "types": ["address"] }, mapConfig Change configuration for Google map widget in serviceability screen: showMap : Show or Hide Google maps - Default false (only address search text input will be shown). height : Height of the map. width : Width of the map. zoom : Zoom level of the map (Default 2) zero is most zoomed. radius : Radius value in meters which use to fetch addresses around given coordinates (Default 100m). defaultCoordinates : Default location to show up in the Google map, when open for the first time (Default - google office). "mapConfig": { "showMap": true, "height": "25rem", "width": "37.75rem", "zoom": 2, "radius": 100, "defaultCoordinates": { "lat": 28, "lng": 77 } }, externalApiToStateMapping To provide configurations in JSON Path format to map Google Place API response to GeographicAddress fields. All possible address-component types Google address can return are listed following: street_address indicates a precise street address. route indicates a named route (such as "US 101"). intersection indicates a major intersection, usually of two major roads. political indicates a political entity. Usually, this type indicates a polygon of some civil administration. country indicates the national political entity, and is typically the highest order type returned by the Geocoder. administrative_area_level_1 indicates a first-order civil entity below the country level. Within the United States, these administrative levels are states. Not all nations exhibit these administrative levels. In most cases, administrative_area_level_1 short names will closely match ISO 3166-2 subdivisions and other widely circulated lists; however this is not guaranteed as our geocoding results are based on a variety of signals and location data. administrative_area_level_2 indicates a second-order civil entity below the country level. Within the United States, these administrative levels are counties. Not all nations exhibit these administrative levels. administrative_area_level_3 indicates a third-order civil entity below the country level. This type indicates a minor civil division. Not all nations exhibit these administrative levels. administrative_area_level_4 indicates a fourth-order civil entity below the country level. This type indicates a minor civil division. Not all nations exhibit these administrative levels. administrative_area_level_5 indicates a fifth-order civil entity below the country level. This type indicates a minor civil division. Not all nations exhibit these administrative levels. administrative_area_level_6 indicates a sixth-order civil entity below the country level. This type indicates a minor civil division. Not all nations exhibit these administrative levels. administrative_area_level_7 indicates a seventh-order civil entity below the country level. This type indicates a minor civil division. Not all nations exhibit these administrative levels. colloquial_area indicates a commonly-used alternative name for the entity. locality indicates an incorporated city or town political entity. sublocality indicates a first-order civil entity below a locality. For some locations may receive one of the additional types: sublocality_level_1 to sublocality_level_5 . Each sublocality level is a civil entity. Larger numbers indicate a smaller geographic area. neighborhood indicates a named neighborhood. premise indicates a named location, usually a building or collection of buildings with a common name. subpremise indicates a first-order entity below a named location, usually a singular building within a collection of buildings with a common name. plus_code indicates an encoded location reference, derived from latitude and longitude. Plus codes can be used as a replacement for street addresses in places where they do not exist (where buildings are not numbered or streets are not named). See Plus Codes logo for details. postal_code indicates a postal code as used to address postal mail within the country. natural_feature indicates a prominent natural feature. airport indicates an airport. park indicates a named park. point_of_interest indicates a named point of interest. Typically, these POI’s are prominent local entities that do not easily fit in another category, such as Empire State Building or Eiffel Tower. For more information, see Address Types and Address Component Types . xternalApiToStateMapping": { "city": "$.address_components[?(@.types[0]=='locality')].long_name", "country": "$.address_components[?(@.types[0]=='country')].long_name", "suburb": "$.address_components[?(@.types[0]=='administrative_area_level_3')].long_name", "postcode": "$.address_components[?(@.types[0]=='postal_code')].long_name", "stateOrProvince": "$.address_components[?(@.types[0]=='administrative_area_level_2')].long_name", "street1": "$.address_components[?(@.types[0]=='street_address')].long_name", "street2": "$.address_components[?(@.types[0]=='route')].long_name", "geocode": "$.address_components[?(@.types[0]=='plus_code')].long_name", "addressLine1": "$.address_components[?(@.types[0]=='intersection')].long_name", "buildingId": "$.address_components[?(@.types[0]=='premise')].long_name", "subDoorNumber": "$.address_components[?(@.types[0]=='subpremise')].long_name", "region": "$.address_components[?(@.types[0]=='administrative_area_level_1')].long_name", "xpos": "$.geometry.location.lat", "ypos": "$.geometry.location.lng" }

4.3.1. Configure Service Address Form

Service address form in checkout can be configured using dynamic-forms.config.json.

The configuration of the Service Address form will affect all users (sessions) currently logged into the application. All recommended configurations should be added through the dynamic-forms.config.json. This file can be accessed at the following path: ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

The Service address form can be configured through the checkoutServiceAddress section in the dynamic-forms.config.json file.

All properties align with the dynamic forms framework. For more information, see the Configurability Framework Guide, section Checkout Service Address Configuration.

4.3.2. Configure Serviceability Address Search Filters

Serviceability address search filters can be configured through the serviceabilityAddressSearchConfig section in the dynamic-forms.config.json file.

This files can be accessed at the following path ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

All properties align with the dynamic forms framework. For more information, see the Configurability Framework Guide, section Dynamic Form Framework.

4.4. Script Parameter Configuration

This parameter configuration will affect all the users (sessions) logged in to the application. All the recommended static configurations are stored in script-config.js file. The path to access the file is ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

Parameter Configuration Description enableAnalytics Use this key to enable or disable analytics using Raygun. raygunKey Raygun key for generating the statistics. googlePlacesAPIKey This key enables google address search to returns address from google address search database. cacheFullRefData This key determines whether full refdata API response to be cached or not by the browser.

4.5. Icons

The Customer Connect UI supports the following icons.

To identify icon names from the above images:

Most of the icon names for the first image will be lowercase single-word product and company names.

If a company or product name contains a space, the icon name will have a hyphen instead of a space

Image Icon Name Copy link Dribble1 Dribble2 Google Pay

For the other images, follow these steps:

Each icon has a keyword on the left.

Convert that keyword into all lowercase letters.

If there are spaces between the words, replace them with hyphens.

4.6. Configuring External Table Names

The External Table Names DA table is configured to support and maintain (fetch/update) any external table (i.e. maintained outside Encompass) through Customer Connect. The tables are supported in a similar manner to DA tables. All such external table names being supported should be added to the External Table Names DA table.

To configure the external tables in the DA table:

Open the External Table Names table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Entity drop-down list, select the entity.

Based on the entity, Entity Type drop-down list will come, select the entity type.

In the Sequence field enter number as you want, it is to make the row indexes unique.

In the Table Name field, enter the external table name. Here, the name should be exactly same as external table name.

If pseudo structure is there for the external table select Yes from the drop-down or vice versa. A project may or may not chose to maintain the table structure as a DA table.

Note DA name should be same as External Table Name and AT(Attribute types) name and data type should be same as column name and type respectively. All external table pseudo structure should be added under Derived Attribute Tables (Lists) tab of the entity type.

In the External Table Function field, enter the function name which will handle Get and Patch calls.

Note One function should be maintained for all the external methods (Get, List or Patch). A sample function has been provided in sample perestapi solution to give a reference as to how to handle external table operations.

4.6.1. Configuring for Service Table

The Service Table configuration will affect all the users (sessions) logged into the application. All the recommended configurations are added through dynamic-forms.config.json and generic-tables.config.json files. The path to access the files is ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

File Parameter Configuration Description dynamic-forms.config.json { "serviceTables": { "External Wireless Service Table": { "Test Table One": { "key": "external_wireless_service_table", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "external_wireless_service_table", "externalTable": "true", "formTag": [ "Consumer", "Residential" ], "title": "HLR Table", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "serviceType", "type": "text", "label": "Service Type", "dataType": "string", "editable": [ "update", "create" ], "order": 1, "aspectRatio": "1", "visibilityType": [ "view", "update", "create" ], "isEventEmit": true, "options": { "stateKey": "service_Type", "apiKey": "$.SERVICE_TYPE" } }, { "key": "status", "type": "text", "label": "Status", "editable": [ "update", "create" ], "dataType": "string", "order": 2, "aspectRatio": "1", "visibilityType": [ "view", "update", "create" ], "options": { "stateKey": "status", "apiKey": "$.STATUS" } } ] } } } } genericTableConfigKey : Configure generic table framework with this framework. The value of genericTableConfigKey should match the main key of config present in the generic table configuration json. Generic table framework brings up the table from json and actions on any record like [view, add, edit, delete] triggers the dynamic config framework and taken forward from there. @type string. Example: external_wireless_service_table externalTable : To identify the table being fetched is from External Source or Internal Source. The parameter is set to true for external tables and false for internal tables. @type boolean. Other properties are inline with dynamic forms framework.

File Parameter Configuration Description generic-tables.config.json *"network_status_test": { "ACTION_BUTTONS": ["edit", "remove", "add"],* "COLUMNS": [ { "labelTranslationKey": "Service Type", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='SERVICE_TYPE')].value"], "displayFormat": "\{param1}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 25 }, { "labelTranslationKey": "Status", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='STATUS')].value"], "displayFormat": "\{param1}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 25 } ] } genericTableConfigKey : To connect the configuration with dynamic forms framework. @type string. Example: network_status_test ACTION_BUTTONS : This configuration is used to affix the buttons to the table records. The action performed by respective buttons is controlled internally based on the table type. @type Array of strings. Example: [add, remove, edit] Other properties are inline with generic table framework.

Important Notes for setting stateKey and apiKey in dynamic forms framework

Response key have spaces or no spaces:

stateKey should follow a camelCase format where words are combined without spaces, and each word begins with a capital letter, just like the content present in the apiKey. Additionally, the content of the stateKey should match the content of the apiKey to ensure consistency.

Refer below example and sample dynamic-forms.config.json:

Sample dynamic-forms.config.json Example "serviceTables": { "Network Service Table": { "Test Table One": { "key": "network_status_test", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "network_status_t", "externalTable" : "true", "formTag": [ "Consumer", "Residential" ], "title": "HLR Table", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "accountName", "type": "text", "label": "Account Name", "dataType": "string", "editable": ["update", "create"], "order": 1, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "accountName", "apiKey": "$.Account Name" } }, { "key": "city", "type": "text", "label": "City", "editable": ["update","create"], "dataType": "string", "order": 2, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "options": { "stateKey": "city", "apiKey": "$.City" } } ] } } } Example 1: { "stateKey": "accountName", "apiKey": "$.Account Name", "apiKeyType": "string" } Example 2: { "stateKey": "city", "apiKey": "$.City", "apiKeyType": "string" }

Response key has underscore ( _ ):

stateKey and apiKey should have the same content and be formatted in the way demonstrated in the below examples, with words combined, capitalised, and separated by underscores.

Refer below example and sample dynamic-forms.config.json:

Sample dynamic-forms.config.json Example "serviceTables": { "Network Service Table": { "Test Table One": { "key": "network_status_test", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "network_status_t", "externalTable" : "true", "formTag": [ "Consumer", "Residential" ], "title": "HLR Table", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "testName", "type": "text", "label": "Test Name", "dataType": "string", "editable": ["update", "create"], "order": 1, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "test_Name", "apiKey": "$.TEST_NAME" } }, { "key": "city", "type": "text", "label": "City", "editable": ["update","create"], "dataType": "string", "order": 2, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "options": { "stateKey": "city", "apiKey": "$.CITY" } } ] } } } Example 1: { "stateKey": "test_Name", "apiKey": "$.TEST_NAME", "apiKeyType": "string" } Example 2: { "stateKey": "city", "apiKey": "$.CITY", "apiKeyType": "string" }

4.6.2. Configuring for Customer Table

The Customer Table Configuration will affect all the users (sessions) logged into the application. All the recommended configurations are added through dynamic-forms.config.json and generic-tables.config.json files. The path to access the files is ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

File Parameter Configuration Description dynamic-forms.config.json "customerRelatedList": { "Loyalty Points": { "Active Points": { "key": "external_table", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "external_table", "externalTable": "true", "formTag": [], "title": "Active Points", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "id", "type": "text", "label": "Serial Number", "dataType": "number", "editable": ["update", "create"], "order": 1, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "point_Id", "apiKey": "$.POINT_ID", "apiKeyType": "integer" }, "validatorsProp": [ { "formMode": ["update"], "validators": { "required": true } } ] }, { "key": "amount", "type": "text", "label": "Amount", "editable": ["update", "create"], "dataType": "number", "order": 2, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "options": { "stateKey": "amount", "apiKey": "$.AMOUNT", "apiKeyType": "integer" } }, { "key": "name", "type": "text", "label": "Reward Name", "dataType": "string", "editable": ["update", "create"], "order": 4, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "name", "apiKey": "$.NAME", "apiKeyType": "string" }, "validatorsProp": [ { "formMode": ["update"], "validators": { "required": true } } ] }, { "key": "expiryDate", "type": "date", "label": "Expiry Date", "dataType": "string", "editable": ["update", "create"], "order": 4, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "expiry_Date", "apiKey": "$.EXPIRY_DATE", "apiKeyType": "string" }, "validatorsProp": [ { "formMode": ["update"], "validators": { "required": true } } ] } ] } } } genericTableConfigKey : Configure generic table framework with this framework. The value of genericTableConfigKey should match the main key of config present in the generic table configuration json. Generic table framework brings up the table from json and actions on any record like [view, add, edit, delete] triggers the dynamic config framework and taken forward from there. @type string. Example: external_table externalTable : To identify the table being fetched is from External Source or Internal Source. The parameter is set to true for external tables and false for internal tables. @type boolean. Other properties are inline with dynamic forms framework.

File Parameter Configuration Description generic-tables.config.json "external_table": { "ACTION_BUTTONS": ["edit", "remove", "add"], "COLUMNS": [ { "labelTranslationKey": "Serial Number", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='POINT_ID')].value"], "displayFormat": "{param1}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 30 }, { "labelTranslationKey": "Amount", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='AMOUNT')].value"], "displayFormat": "{param1}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 30 }, { "labelTranslationKey": "Reward Name", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='NAME')].value"], "displayFormat": "{param1}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 30 }, { "labelTranslationKey": "Expiry Date", "mainDataSource": { "apiJsonpathList": ["$.recordCharacteristics[?(@.name=='EXPIRY_DATE')].value"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, "subScriptDataSource": {}, "sortKey": "name", "columnWidth": 30 } ] } genericTableConfigKey : To connect the configuration with dynamic forms framework. @type string. Example: external_table ACTION_BUTTONS: This configuration is used to affix the buttons to the table records. The action performed by respective buttons is controlled internally based on the table type. @type Array of strings. Example: [add, remove, edit] Other properties are inline with generic table framework.

Important Notes for setting stateKey and apiKey in dynamic forms framework

When response key have white spaces or no spaces:

stateKey should follow a camelCase format where words are combined without spaces, and each word begins with a capital letter, just like the content present in the apiKey. Additionally, the content of the stateKey should match the content of the apiKey to ensure consistency.

Refer below example and sample dynamic-forms.config.json:

Sample dynamic-forms.config.json Example "customerRelatedList: { "Example Customer Table": { "Test Table One": { "key": "external_table", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "external_table", "externalTable" : "true", "formTag": [ "Consumer", "Residential" ], "title": "Example Customer Table", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "accountName", "type": "text", "label": "Account Name", "dataType": "string", "editable": ["update", "create"], "order": 1, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "accountName", "apiKey": "$.Account Name" } }, { "key": "city", "type": "text", "label": "City", "editable": ["update","create"], "dataType": "string", "order": 2, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "options": { "stateKey": "city", "apiKey": "$.City" } } ] } } } Example 1: { "stateKey": "accountName", "apiKey": "$.Account Name", "apiKeyType": "string" } Example 2: { "stateKey": "city", "apiKey": "$.City", "apiKeyType": "string" }

When response key has underscore ( _ ):

stateKey and apiKey should have the same content and be formatted in the way demonstrated in the below examples, with words combined, capitalized, and separated by underscores.

Refer below example and sample dynamic-forms.config.json:

Sample dynamic-forms.config.json Example "customerRelatedList": { "Example Customer Table": { "Test Table One": { "key": "external_table", "entityType": "derivedAttribute", "rackName": "CUSTOMER", "genericTableConfigKey": "external_table", "externalTable" : "true", "formTag": [ "Consumer", "Residential" ], "title": "Example Customer Table", "gridColumnLength": 2, "formEditable": true, "order": 1, "fields": [ { "key": "testName", "type": "text", "label": "Test Name", "dataType": "string", "editable": ["update", "create"], "order": 1, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "isEventEmit": true, "options": { "stateKey": "test_Name", "apiKey": "$.TEST_NAME" } }, { "key": "city", "type": "text", "label": "City", "editable": ["update","create"], "dataType": "string", "order": 2, "aspectRatio": "1", "visibilityType": ["view", "update", "create"], "options": { "stateKey": "city", "apiKey": "$.CITY" } } ] } } } Example 1: { "stateKey": "test_Name", "apiKey": "$.TEST_NAME", "apiKeyType": "string" } Example 2: { "stateKey": "city", "apiKey": "$.CITY", "apiKeyType": "string" }

4.7. Configuring Expansion fields of Payment Table

The Expansion fields of Payment Table configuration will affect all the users (sessions) logged into the application. All the recommended configurations are added through generic-tables.config.json files. The path to access the files is ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

File Parameter Configuration Description generic-tables.config.json Sample json of Expansion fields of Payment Table : "PAYMENTS_TABLE": { "ACTION_BUTTONS": ["view"], "EXPANSION_FIELDS": [ { "labelTranslationKey": "External Reference Number", "apiJsonpathList": ["$.characteristic[?(@.name=='ExternalReferenceNumber')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Receipt Date", "apiJsonpathList": ["$.characteristic[?(@.name=='EntryDate')].value"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, { "labelTranslationKey": "Batch Number", "apiJsonpathList": ["$.characteristic[?(@.name=='BatchNumber')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Canceled By", "apiJsonpathList": ["$.orderCharacteristic[?(@.name=='CancelledBy')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Created By", "apiJsonpathList": ["$.characteristic[?(@.name=='CreatedBy')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "VAT Type", "apiJsonpathList": ["$.characteristic[?(@.name=='VATType')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "VAT ID", "apiJsonpathList": ["$.characteristic[?(@.name=='VATId')].value"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Tax Amount", "apiJsonpathList": ["$.taxAmount.value", "$.taxAmount.unit"], "displayFormat": "{param1} {param2}" }, { "type": "OBJECT", "key": "PAYMENTS_TABLE_EXPANSION_PAYMENT_METHOD_DETAILS", "apiJsonpathList": ["$.paymentMethod.details"] }, { "key": "PAYMENTS_TABLE_EXPANSION_PAYMENT_ITEMS", "type": "TABLE", "tableName": "Payment Items", "childTableDataSourcePath": "$.paymentItem", "COLUMNS": [ { "labelTranslationKey": "Item Type", "mainDataSource": { "apiJsonpathList": ["$.item['@referredType']"], "displayFormat": "{param1}" } }, { "labelTranslationKey": "Reference Number", "mainDataSource": { "apiJsonpathList": ["$.item.id"], "displayFormat": "{param1}" } }, { "labelTranslationKey": "Allocation Date", "mainDataSource": { "apiJsonpathList": ["$.item.date"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" } }, { "labelTranslationKey": "Status", "mainDataSource": { "apiJsonpathList": ["$.item.status"], "displayFormat": "{param1}" } }, { "labelTranslationKey": "Amount", "mainDataSource": { "apiJsonpathList": ["$.item.totalAmount.value", "$.item.totalAmount.unit"], "displayFormat": "{param2}{param1}" } } ] }, { "key": "PAYMENTS_TABLE_EXPANSION_PAYMENT_REJECTION", "type": "TABLE", "tableName": "Payment Rejection", "childTableDataSourcePath": "$", "COLUMNS": [ { "labelTranslationKey": "Rejection Date", "mainDataSource": { "apiJsonpathList": ["$.characteristic[?(@.name=='RejectionDate')].value"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" } }, { "labelTranslationKey": "Rejection Reason", "mainDataSource": { "apiJsonpathList": ["$.characteristic[?(@.name=='RejectionReason')].value"], "displayFormat": "{param1}" } }, { "labelTranslationKey": "Rejected By", "mainDataSource": { "apiJsonpathList": ["$.characteristic[?(@.name=='RejectedBy')].value"], "displayFormat": "{param1}" } } ] }, { "key": "PAYMENTS_TABLE_EXPANSION_PAYMENT_COMMENTS", "type": "TABLE", "tableName": "Comments", "childTableDataSourcePath": "$.comments", "COLUMNS": [ { "labelTranslationKey": "Comments", "mainDataSource": { "apiJsonpathList": ["$.comment"], "displayFormat": "{param1}" } } ] } ], "EXCEL_DOWNLOAD": { "EXCEL_FIELDS": [ { "labelTranslationKey": "Receipt Number", "apiJsonpathList": [ "$.id" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Type", "apiJsonpathList": [ "$.paymentMethod.name" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Receipt Date", "apiJsonpathList": [ "$.characteristic[?(@.name=='EntryDate')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Status", "apiJsonpathList": [ "$.status" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Amount", "apiJsonpathList": [ "$.totalAmount.value", "$.totalAmount.unit" ], "displayFormat": "{param2}{param1}" }, { "labelTranslationKey": "Created By", "apiJsonpathList": [ "$.characteristic[?(@.name=='CreatedBy')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "External Reference Number", "apiJsonpathList": [ "$.characteristic[?(@.name=='ExternalReferenceNumber')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Location", "apiJsonpathList": [ "$.channel.name" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Payment Date", "apiJsonpathList": [ "$.paymentDate" ], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, { "labelTranslationKey": "Batch Number", "apiJsonpathList": [ "$.characteristic[?(@.name=='BatchNumber')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Order Id", "apiJsonpathList": [ "$.paymentItem[?(@.item['@referredType']=='productOrder')].item.id" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Case", "apiJsonpathList": [ "$.case.name" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "VAT ID", "apiJsonpathList": [ "$.characteristic[?(@.name=='VATId')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "VAT Type", "apiJsonpathList": [ "$.characteristic[?(@.name=='VATType')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Rejection Date", "apiJsonpathList": [ "$.characteristic[?(@.name=='RejectionDate')].value" ], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, { "labelTranslationKey": "Rejection Reason", "apiJsonpathList": [ "$.characteristic[?(@.name=='RejectionReason')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Rejected By", "apiJsonpathList": [ "$.characteristic[?(@.name=='RejectedBy')].value" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Comments", "apiJsonpathList": [ "$.comments" ], "displayFormat": "{param1, join, $.comment }" }, { "labelTranslationKey": "Unique Reference", "apiJsonpathList": [ "$.paymentMethod.details.uniqueReference" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Method", "apiJsonpathList": [ "$.paymentMethod.details.method" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Details", "apiJsonpathList": [ "$.paymentMethod.details.details" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Description", "apiJsonpathList": [ "$.paymentMethod.details.description" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Loyalty Points Conversion Factor", "apiJsonpathList": [ "$.paymentMethod.details.loyaltyPointsConversionFactor" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Loyalty Points ConsumedDetails", "apiJsonpathList": [ "$.paymentMethod.details.loyaltyPointsConsumed" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Name On Card", "apiJsonpathList": [ "$.paymentMethod.details.nameOnCard" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Card Number", "apiJsonpathList": [ "$.paymentMethod.details.cardNumber" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Brand", "apiJsonpathList": [ "$.paymentMethod.details.brand" ], "displayFormat": "{param1}" }, { "labelTranslationKey": "Expiration Date", "apiJsonpathList": [ "$.paymentMethod.details.expirationDate" ], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" } ], "showExport": true, "csvExportData": { "fileName": "", "label": "" } } } PAYMENTS_TABLE : This section of the configuration file pertains to settings related to payments. ACTION_BUTTONS : Specifies the actions that can be performed on payment entries, with "view" being the only action allowed in this case. EXPANSION_FIELDS : Defines additional fields and details to display when expanding payment rows. labelTranslationKey : A translation key for the field label. apiJsonpathList : JSONPath expressions to extract data from the API response. displayFormat : Specifies how the extracted data should be formatted for display. childTableDataSourcePath : It specifies where to find the data for the sub-table or nested table within the main table. For example, in the context of the configuration file provided, childTableDataSourcePath specifies where to find the data for items like payment items, rejection details, or comments within the main payment table. mainDataSource : The source and mapping for the primary (main content) data of this column. tableName : This denotes the name of the table. It provides a label or identifier for the table being defined in the configuration file. type : This specifies the type of data or structure of the field. It indicates whether the field represents a key-value pair, an object, or a table (list of items). EXCEL_DOWNLOAD : This section contains settings related to exporting payment data to Excel. EXCEL_FIELDS : Defines the fields that will be included in the exported Excel file. Each field specifies the data to be extracted and the format to be used in the Excel file. showExport : A boolean value (true or false) indicating whether the export to Excel icon should be shown in the user interface. If set to true, the export functionality will be available. csvExportData : Contains settings for exporting data to a CSV file. fileName : Specifies the default file name for the exported CSV file. label : Provides a label or description for the CSV export functionality.

4.7.1. Example of Applied Transaction Table

To configure fields in expansion area:

Open generic-tables.config.json (src\assets\config\generic-tables.config.json).

Add attribute configuration to EXPANSION_FIELDS of APPLIED_TRANSACTIONS section in generic-tables.config.json

labelTranslationKey is used to display title of attribute. This is the translation key in library\sv-translate\src\lib\i18n\glossary\en.ts (GLOSSARY → GENERIC_CONFIGURATION_TABLE).

apiJsonpathList is the json path from api response.

displayFormat is the format to be used.

Sample configuration:

"APPLIED_TRANSACTIONS": { "EXPANSION_FIELDS": [ { "labelTranslationKey": "TYPE", "apiJsonpathList": ["$.accountingEntry"], "displayFormat": "{param1}" }, { "labelTranslationKey": "CREATED BY", "apiJsonpathList": ["$.characteristic[?(@.name=='createdBy')].value"], "displayFormat": "{param1}" } ] }

4.7.2. Example of Unbilled Transaction Table

To configure fields in expansion area:

Open generic-tables.config.json (src\assets\config\generic-tables.config.json).

Add attribute configuration to EXPANSION_FIELDS of UNBILLED_TRANSACTIONS section in generic-tables.config.json

labelTranslationKey is used to display the title of attribute. This is the translation key in library\sv-translate\src\lib\i18n\glossary\en.ts (GLOSSARY → GENERIC_CONFIGURATION_TABLE).

apiJsonpathList is the json path from api response.

displayFormat is the format to be used.

Sample configuration:

"UNBILLED_TRANSACTIONS": { "EXPANSION_FIELDS": [ { "labelTranslationKey": "ID", "apiJsonpathList": ["$.id"], "displayFormat": "{param1}" }, { "labelTranslationKey": "DESCRIPTION", "apiJsonpathList": ["$.characteristic[?(@.name=='ReceiverAccountNumber')].value"], "displayFormat": "{param1}" } ] },

4.7.3. Example of Invoice Transaction Table

To configure fields in expansion area:

Open generic-tables.config.json (src\assets\config\generic-tables.config.json).

Add attribute configuration to EXPANSION_FIELDS of INVOICE section in generic-tables.config.json

labelTranslationKey is used to display the title of attribute. This is the translation key in library\sv-translate\src\lib\i18n\glossary\en.ts (GLOSSARY → GENERIC_CONFIGURATION_TABLE).

apiJsonpathList is the json path from api response.

displayFormat is the format to be used.

Sample configuration:

"INVOICE": { "EXPANSION_FIELDS": [ { "labelTranslationKey": "ID", "apiJsonpathList": ["$.id"], "displayFormat": "{param1}" }, { "labelTranslationKey": "CREATED BY", "apiJsonpathList": ["$.characteristic[?(@.name==EventType)].value"], "displayFormat": "{param1}" } ] }

4.8. Configuring Service Documents Tab

The configuration of the Documents tab will affect all users (sessions) currently logged into the application. All recommended configurations should be added through the dynamic-forms.config.json and generic-tables.config.json files. These files can be accessed at the following path: ./assets/config.

Note Refresh the Customer Connect application to reflect the changes made to the configuration file.

dynamic-forms.config.json:

The Service Document Upload form can be configured through the uploadDocumentServiceDetails section in the dynamic-forms.config.json file.

All properties align with the dynamic forms framework. For more information, see Configurability Framework Guide.

Sample dynamic-forms.config.json of Documents tab:

"uploadDocumentServiceDetails": { "Upload Document": { "uploadDocumentForm": { "key": "uploadDocumentForm", "entityType": "document", "rackName": "DOCUMENT", "formTag": [ "Consumer", "Residential", "Registered Prepaid", "Anonymous Prepaid", "Business", "Registered", "Unregistered Prepaid", "Corporate", "Prepaid Customer", "Hybrid Customer", "Dealer", "Small Business", "API Test Business" ], "title": "Document Details", "gridColumnLength": 2, "isEmptyRack": true, "formEditable": true, "order": 1, "fields": [ { "key": "uploadDocumentType", "type": "dropdown", "label": "Document Type", "dataType": "string", "editable": ["create", "update"], "order": 1, "aspectRatio": "1", "visibilityType": ["create", "view", "update"], "isDependency": true, "options": { "stateKey": "documentType", "store": "refData.refDataCache.RT-perestapi.imp.DOCUMENT_TYPE" }, "validatorsProp": [ { "formMode": ["update", "create"], "validators": { "required": true } } ], "dependency": [ { "selectedRule": ["Contract"], "child": ["offerName"], "type": "SHOW_DEPENDENT_FIELD" } ] }, { "key": "offerName", "parent": "uploadDocumentType", "type": "dropdown", "label": "Offer Name", "dataType": "string", "editable": ["create", "update"], "order": 2, "aspectRatio": "1", "visibilityType": ["create", "view", "update"], "options": { "stateKey": "offerName" }, "validatorsProp": [ { "formMode": ["update", "create"], "validators": { "required": true } } ] }, { "key": "documentList", "type": "file", "label": "Documents", "dataType": "string", "editable": ["create", "update"], "order": 3, "aspectRatio": "2", "visibilityType": ["create", "update"], "options": { "stateKey": "documentList", "apiKey": "", "apiKeyType": "" }, "validatorsProp": [ { "formMode": ["update", "create"], "validators": { "required": true } } ], "fileWidgetConfig": { "isEditable": true, "showDelete": true } } ] } } }

generic-tables.config.json:

Service Documents Table columns can be configured through DOCUMENTS_TABLE section in generic-table.config.json.

All properties align with the generic table framework.

Sample generic-tables.config.json of Documents tab:

"DOCUMENTS_TABLE": { "ACTION_BUTTONS": ["view"], "COLUMNS": [ { "labelTranslationKey": "TYPE", "mainDataSource": { "apiJsonpathList": ["$.type"], "displayFormat": "{param1}" }, "subScriptDataSource": { "apiJsonpathList": ["$.offerName"], "displayFormat": "{param1, select, undefined {} other {{param1}}}" }, "sortKey": "name" }, { "labelTranslationKey": "NAME", "mainDataSource": { "apiJsonpathList": ["$.name"], "displayFormat": "{param1}" }, "sortKey": "name" }, { "labelTranslationKey": "STATUS", "mainDataSource": { "apiJsonpathList": ["$.lifecycleState"], "displayFormat": "{param1}" }, "sortKey": "name" }, { "labelTranslationKey": "SIZE", "mainDataSource": { "apiJsonpathList": ["$.attachment[0].size", "$.attachment[0].sizeUnit"], "displayFormat": "{param1}{param2}" }, "sortKey": "name" }, { "labelTranslationKey": "ADDED", "mainDataSource": { "apiJsonpathList": ["$.creationDate"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, "sortKey": "name", "columnWidth": 10 }, { "labelTranslationKey": "UPDATED", "mainDataSource": { "apiJsonpathList": ["$.lastUpdate"], "displayFormat": "{param1, dateTime, DD MMM yyyy hh:mm A}" }, "sortKey": "name", "columnWidth": 10 } ], "EXPANSION_FIELDS": [ { "labelTranslationKey": "Description", "apiJsonpathList": ["$.description"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Document Type", "apiJsonpathList": ["$.attachment[0].mimeType"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Uploaded By", "apiJsonpathList": ["$.createdBy"], "displayFormat": "{param1}" }, { "labelTranslationKey": "Offer Name", "apiJsonpathList": ["$.offerName"], "displayFormat": "{param1}", "isVisible": "{{$.offerName}} != ''" }, { "labelTranslationKey": "Document Requirement", "apiJsonpathList": ["$.isDocumentRequired"], "displayFormat": "{param1}", "isVisible": "{{$.offerName}} != ''" } ] }

5. Common Configuration

5.1. Security Framework

The Customer Connect provides a security framework which grants or restricts access to the features of the application. Access levels enable administrators to manage user access. Users' access level determines which tabs they can view and perform operations.

The security framework comprises three levels:

Security Level Priority Description Object 1 (Highest) An object represents the screen that is loaded. Object example: Customer, Contact, Billing screens. Each customer/contact has one object access level associated with it. Tab 2 The Tab will be on the screen. Tab example: Overview, Representative Contacts, Customer Hierarchy and Documents. Field 3 Fields are within a Tab/Screen.

Note The object security level is given the highest priority, and it overrides the security levels of the Tab, menu and field. The Tab security level overrides the security level of the field.

5.1.1. Object Access Level

Each customer or contact will be associated with a security group.

The security group of the customer or contact in the application is mapped to a user security group.

Note The store location selectors like customerObjectAccessLevel and contactObjectAccessLevel are used to remap to the menuAccessLevel. Remapping is done using the security-selector.ts file.

Context Store Location Description Customer security - customerObjectAccessLevel Provides object access levels of the customer to user. Contact security - contactObjectAccessLevel Provides object access levels of the contact to user.

There are three security access levels, and each level represents UI accessibility.

Access Level Description NO_ACCESS No access to UI elements. VIEW Read-only access to UI elements. Operations such as editing or adding are hidden in the UI. UPDATE Complete access to UI elements. Users can switch between read-only and edit mode in the UI.

For example, a customer (ID - 104148) with customerObjectAccessLevel "UPDATE" access levels are derived based on the customer’s security group and the user’s security group.

In the below case, the user can switch between read-only and edit mode in the UI.

Customer’s security group: "DEVELOPMENT"

User’s security group: "DEVELOPMENT"

5.1.2. List of Tab/Menu Security Access Level

The following is a list of the Menu Items that control access to certain operations within the Customer Connect UI. Security profiles given access to these Menu Items will be allowed to view/perform the relative screen/operation as explained in further sections.

Note If any menu item is inaccessible (i.e., access level 0) on the Customer information, the respective widgets on the Customer overview screen, as well as certain hyperlinks and other redirecting points, will also be inaccessible. If any menu item is inaccessible (i.e., access level 0) on the service details screen, the respective widgets on the service overview screen, as well as certain hyperlinks and other redirecting points, will also be inaccessible.

Menu Item ID Menu Item Code Menu Item Code Description Customer Connect Screen Mapping Customer Connect Behaviour for No Access (0) Customer Connect Behaviour for View Access (1) Customer Connect Behaviour for Edit/Update Access (3) 1000 NGUI_CUST_REPR_CONTS Representative Contacts tab Customer Information screen Customer representative contacts tab is not displayed. Customer Representative Contacts tab view icon is present, which means the CSR can open contacts, but all edit options like 'Add New Contacts', 'Make Primary' button, 'Edit Role' button, etc., are not displayed. Edit options like 'Add New Contacts', 'Make Primary' button, 'Edit Role' button, etc., are displayed and can be updated. 1001 NGUI_CUST_HRC Customer Hierarchy tab Customer Information screen Customer hierarchy tab and customer hierarchy icon is not displayed. Customer Hierarchy tab view icon is present, which means the CSR can open contact and all edit options like add child customer option , Delink button, etc., are not displayed. Options like 'Add Child Customer', 'Delink' button, etc., are displayed and can be updated. 1002 NGUI_CUST_DOCS Documents tab Customer Information screen Customer documents tab is not displayed. Customer Documents tab, the 'Add New Document' button is displayed, and the CSR can add a new document. However, for already added documents, only the view icon is displayed, and the 'Email Document' and 'Delete Document' options are not displayed. The 'Email Document' and 'Delete Document' options are displayed and allow sending mail and delete. 1003 NGUI_CONT_ADNL_INFO Additional Information tab Contact Information screen Additional Information tab is not displayed. In the Additional Information tab, all edit buttons are not displayed, and all information is available in view mode. The 'Edit All' and 'Edit' icons in each rack are visible and allow updates. 1004 NGUI_CONT_ASSOC_CUST Associated Customers tab Contact Information screen Associated Customers tab is not displayed. In the Associated Customers tab, the 'Add' button is not displayed, and the CSR can view customers via the view icon. The 'Add' icon is displayed and allows adding the customer to the contact. 1005 NGUI_CONT_DOCS Contact Documents tab Contact Information screen Contact Documents tab is not displayed. Contact Documents tab is displayed, but the 'Add' button is not displayed. Contact tab is displayed with an 'Add' button, and it is possible to add documents. 1006 NGUI_CONT_SETTINGS Settings tab Contact Information screen Contact Settings tab is not displayed. In the Contact Settings tab, all edit buttons are not displayed. Edit icons are displayed in each rack and allow updates. 1008 NGUI_BILL_PAYMENTS Payments tab Billing screen Billing payments tab is not displayed. Billing Payments tab is displayed in view mode, and it is possible to download documents. The toggle is also working. Kebab menu is displayed with 'Print Receipt', 'Resend Receipt', and 'Cancel Payment' options. 1009 NGUI_BILL_DISPUTES Disputes tab Billing screen Billing Disputes tab is not displayed. Billing Dispute tab is displayed, and it is possible to view the disputes. The 'Resolve' button under the action is not visible. Resolve button under Action is visible, and on click, it shows the dispute issue form. 1011 NGUI_CONT_OVERVIEW Contact Overview tab Contact Information screen Contact Overview tab is displayed but unable to edit. 0 and 1 behaves similar (Overview screen will be displayed in view mode). The 'Edit All' and 'Edit' icons in each rack are visible and allow updates. 1012 NGUI_CUST_OVERVIEW Customer Overview tab Customer Information screen Customer Overview tab is still displayed, and all widgets are visible. The CSR can click on the 'See All' button of a widget, and it navigates into that widget. 0 and 1 behaves similar (Overview screen will be displayed in view mode). The 'Edit All' and 'Edit' icons in each rack are visible and allow updates. 1013 NGUI_BILL_OVERVIEW Billing Overview tab Billing screen Billing Overview tab is not displayed. Billing Overview tab is displayed with view mode and Account Action drop-down or button is not visible. Account Action button or drop-down is visible. 1014 NGUI_OPS_MAKE_PAYMENT Make Payment Menu Billing Overview tab Make Payment option in account options drop-down is not displayed. Make Payment option in avaialble in the account action drop-down and able to make the payment. Make Payment option is available in the Account Action drop-down, and it is possible to make the payment. 1015 NGUI_OPS_CREATE_ADJUSTMENT Create Adjustment Menu Billing Overview tab Create Adjustment option in account options drop-down is not displayed. Create Adjustment option in avaialble in the account action drop-down. Create Adjustment option is available in the Account Action drop-down. 1016 NGUI_OPS_CREATE_DISPUTE Create Dispute Menu Billing Overview tab Create Dispute option in account options drop-down is not displayed. Create Dispute option in avaialble in the account action drop-down. Create Dispute option is available in the Account Action drop-down. 1017 NGUI_OPS_TRANSFER_BALANCE Transfer Balance Menu Billing Overview tab Transfer Balance option in account options drop-down is not displayed. Transfer Balance option in avaialble in the account action drop-down. Transfer Balance option is available in the Account Action drop-down. 1018 NGUI_OPS_ONE_OFF_CHARGES One-Off Charges Menu Billing Overview tab One-off Charge option in account options drop-down is not displayed. One-off Charge option in avaialble in the account action drop-down. One-off Charge option is available in the Account Action drop-down. 1020 NGUI_OPS_GENERATE_IMMED_BILL Generate Immediate Bill Menu Billing Overview tab Generate Immediate Bill option in account options drop-down is not displayed. If all options in account options drop-down is set to zero then account options drop-down is not displayed. Generate Immediate option in avaialble in the account action drop-down. Generate Immediate option is available in the Account Action drop-down. 1022 NGUI_SERV_OVERVIEW Service Overview tab Current Products/Cancelled Products Service Overview widget and overview tab is not displayed. 0 and 1 behaves similar (Overview screen will be displayed in view mode). Edit icon will be available and allow editing. 1023 NGUI_BILL_TRANSACTIONS Transactions tab Billing screen Billing Transactions tab is not displayed. Billing Transactions tab is displayed in read-only mode. The checkbox for transaction selection is not displayed, so that can’t initiate a dispute for the transaction. The checkbox for the transaction is displayed, and upon selecting it, the option for dispute creation is visible. 1024 NGUI_BILL_STATEMENTS Statements tab Billing screen Billing Invoices and Statement tab is not displayed. Billing Invoices and Statement tab is displayed in view mode. The Kebab menu is not displayed. Billing Invoices and Statement tab is displayed and can be selected. The kebab menu is also displayed. 1025 NGUI_BILL_SETTINGS Billing Settings tab Billing screen Billing Settings tab is not displayed. Billing Settings tab is displayed in read-only mode. The edit icon is not visible in all racks, and the 'Add' button in tax exemption is also not visible. The toggle icon is enabled in the view, allowing toggling on/off. Edit icon is visible and allows editing the details. In tax exemption, the Add button is visible and allows adding documents. 1026 NGUI_OPS_RECHARGE Recharge Menu Billing Overview tab Recharge is not displayed. Recharge option is available in the Account Action drop-down. Recharge option in avaialble in the Account Action drop-down. 1029 NGUI_OPS_CANCEL_SERVICE Cancel Service Menu Service Detail screen Cancel Service option is not displayed in Kebab menu of service. Option is visible in the Kebab menu. Option is visible in the Kebab menu. 1030 NGUI_OPS_CHANGE_PLAN Change Plan Menu Service Details screen Change Plan option is not displayed in Kebab menu of service. Option is visible in the Kebab menu. Option is visible in the Kebab menu. 1031 NGUI_OPS_ADD_CHILD_OFFER Add Child Offer Menu Service Details screen Add Child Offer option is not displayed in Kebab menu of service. Option is visible in the Kebab menu. Option is visible in the Kebab menu. 1033 NGUI_OPS_CREATE_CONSUMER_CUST Consumer Customer Creation Option Customer Creation form Create Consumer Customer option while customer creation is displayed. It is present in read-only mode or greyed out, and the Consumer option cannot be selected. Option is enabled for selection and proceed. 1034 NGUI_OPS_CREATE_CORPORATE_CUST Corporate Customer Creation Option Customer Creation form Create Corporate Customer option while customer creation is displayed. It is present in read-only mode or greyed out, and the Corporate option cannot be selected. Option is enabled for selection and proceed. 1035 NGUI_OPS_SKIP_VALIDATION Skip Validation Contact Validation panel Skip Validation button on prospect validation panel is not displayed. 0 and 1 behaves similar(Not displayed). Skip validation hyperlink is enable and allow to click and proceed further. 1036 NGUI_OPS_PAYMENT_METHOD Saved Payment Method Billing Settings tab Saved Payment Methods section in Billing Settings tab is not displayed. Edit and Delete icons are disabled and Add button is hidden. Able to add, edit, and delete the payment methods. 1037 NGUI_OPS_PROMISE_TO_PAY Payment Arrangment Collection Overview tab Payment Arrangement button is not displayed. Payment Arrangement button will not be displayed. Payment Arrangement button will be displayed. 1038 NGUI_COLL_OVERVIEW Collection Overview tab Collection screen Collection Overview is not displayed. Collection Overview is displayed with view only mode, and the CSR is unable to edit. CSR can able to edit the details. 1041 NGUI_OPS_COLL_SUSPENSION Add Grace Period Collection Overview tab Collection Grace period tab is not displayed. Collection Grace Period tab is displayed, but it is not possible to create or delete the grace period. Collection Grace Period tab is displayed, and it is possible to create and delete the grace period. 1042 NGUI_OPS_EXTEND_BALANCE_EXPIRY Extend Balance Expiry Date Billing Overview tab Extend Balance expiry date is not displayed. Option is enabled for selection and proceed. Option is enabled for selection and proceed. 1044 NGUI_OPS_VOUCHER_DETAILS Detail Button in Voucher Discharge Issue Voucher Discharge Issue form Details button in Voucher Discharge Issue type is not displayed. The Details button in Voucher Discharge type is displayed and is working. The CSR is able to click it and view the voucher details. 1 and 3 behave similarly. The Details button in Voucher Discharge type is displayed and is working. The CSR is able to click it and view the voucher details. 1045 NGUI_PAY_CASH_tab Cash tab Payment tab in Multiple Order flow checkout screen or payment form. Cash tab in payment methods on the payment page is not displayed. The tab is present in read-only or view mode, and it is not possible to enter or edit anything. Able to enter the details and submit them. 1046 NGUI_PAY_CREDIT_CARD_tab Credit Card tab Payment tab in Multiple Order flow checkout screen or payment form. Payment Credit Card tab in payment methods on the payment page is not displayed. The tab is present in read-only or view mode, and it is not possible to enter or edit anything. Able to enter the details and submit them. 1048 NGUI_PAY_LOYALTY_POINTS_tab Loyalty Points tab Payment tab in Multiple Order flow checkout screen or payment form. Payment Loyalty Points tab in payment methods on the payment page is not displayed. The tab is present in read-only or view mode, and it is not possible to enter or edit anything. Able to enter the details and submit them. 1049 NGUI_PAY_OTHERS_tab Payment Others tab Payment tab in Multiple Order flow checkout screen or payment form. Others tab in payment methods on the payment page is not displayed. The tab is present in read-only or view mode, and it is not possible to enter or edit anything. Able to enter the details and submit them. 1050 NGUI_ANON_VOUCHER_RECHARGE Reedem Voucher icon CSR Toolbox Voucher Discharge option is not displayed. Able to view and also perform the voucher discharge from the right panel in CCUI. Able to view and also perform the voucher discharge from the right panel in CCUI. 1051 NGUI_OPS_MODIFY_OFFER Modify Offer Menu Service Detail screen Modify Offer option from Kebab menu of service is not displayed. Option will be displayed in the Kebab menu. Option will be displayed in the Kebab menu. 1052 NGUI_INVOICE_SEND_REPRINT_REQUEST Invoice Reprint Request Menu Invoice & Statements tab Invoice Reprint Request option from Kebab menu of invoice is not displayed. The Invoice Reprint Request menu option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1053 NGUI_INVOICE_DOWNLOAD Download Invoice Menu Invoice & Statements tab Invoice Download option from Kebab menu of invoice is not displayed. Invoice Download option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1054 NGUI_INVOICE_EXTEND_PAY_DUE_DATE Extend Pay Due Date Menu Invoice & Statements tab Invoice Extend Pay Due option from Kebab menu of invoice is not displayed. Invoice Extend Pay Due option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1055 NGUI_INVOICE_RESEND_INVOICE Resend Invoice Menu Invoice & Statements tab Resend invoice option from Kebab menu of invoice is not displayed. Resend invoice option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1056 NGUI_INVOICE_DISPUTE Dispute Menu Invoice & Statements tab Dispute option from Kebab menu of invoice is not displayed. Dispute option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1058 NGUI_INVOICE_PAY Pay Menu Invoice & Statements tab Invoice pay button after opening invoice and pay option from Kebab menu of invoice both are is not displayed. Invoice pay menu option will appear and be accessible in the UI. Option will be displayed in the Kebab menu. 1059 NGUI_OPS_COLL_SKIP_STEP Edit Treatment Step Collection Overview tab Edit Treatment step icon is not displayed. Edit Treatment step icon will not be displayed. Allowing to Skip the Treatment steps (Edit Treatment step Icon will display). 1060 NGUI_OFFERS Offers Primary Navigation pane Offers in primary nevigation menu is not displayed. Offers in the primary navigation are displayed and working. Clicking on it navigates to the offers selection page. 1 and 3 are behaving similarly. Offers in the primary navigation are displayed and working. Clicking on it navigates to the offers selection page. 1061 NGUI_CUSTOMER_INFORMATION Customer Information Customer Secondary Navigation pane Customer Information is not displayed. Customer Information is displayed, and all tabs under it are editable by the CSR. 1 and 3 are behaving similarly. Customer Information is displayed, and all tabs under it are editable by the CSR. 1062 NGUI_CUSTOMER_BILLING Billing Customer Secondary Navigation pane Customer Billing is not displayed. Customer Billing is displayed. 1 and 3 are behaving similarly. Customer Billing is displayed. 1063 NGUI_CUSTOMER_ORDERS Orders Customer Secondary Navigation pane Customer Orders is not displayed. Customer Orders is displayed. 1 and 3 are behaving similarly. Customer Orders is displayed. 1064 NGUI_CUSTOMER_CASES Cases Customer Secondary Navigation pane Customer Cases is not displayed. Customer Cases is displayed. 1 and 3 are behaving similarly. Customer Cases is displayed. 1065 NGUI_CUSTOMER_RESERVED_NUMBERS Reserved Numbers Customer Secondary Navigation pane Customer Reserved Numbers is not displayed. Customer Reserved Numbers is displayed. 1 and 3 are behaving similarly. Customer Reserved Numbers is displayed 1066 NGUI_CUSTOMER_HISTORY History Customer Secondary Navigation pane Customer History is not displayed. Customer History is displayed. 1 and 3 are behaving similarly. Customer History is displayed. 1068 NGUI_CUSTOMER_COLLECTIONS Collections Customer Secondary Navigation pane Collections is not displayed. Collections is displayed. 1 and 3 are behaving similarly. 1069 NGUI_CUSTOMER_CURRENT_PRODUCTS Current Products Customer Secondary Navigation pane Current Products is not displayed. Current Products is displayed. 1 and 3 are behaving similarly. 1070 NGUI_CUSTOMER_CANCELLED_PRODUCTS Cancelled Products Customer Secondary Navigation pane Cancelled Products is not displayed. Cancelled Products is displayed. 1 and 3 are behaving similarly. 1071 NGUI_SERV_ENTITLEMENT Service Entitlement tab Service Details screen Entitlement is not displayed. Present in read-only or view mode, unable to edit. The Transfer Unit option will be displayed and allows the transfer. 1072 NGUI_SERV_SPEND_LIMIT Service Spend Limit tab Service Details screen Spend Limit is not displayed. Present in read-only or view mode, unable to edit. The Edit icon will be displayed and allows editing the limits. 1073 NGUI_SERV_ADDONS Service Addons tab Service Details screen Service Addons tab is not displayed. Present in read-only or view mode, unable to edit. Able to view the Add icon and change the status of the offer. 1074 NGUI_SERV_VAS Service VAS tab Service Details screen Service VAS tab is not displayed. Present in read-only or view mode, unable to edit. Able to view the Add icon and change the status of the offer. 1075 NGUI_SERV_DEVICE Service Device tab Service Details screen Service Device tab is not displayed. Present in read-only or view mode, unable to edit. Able to view the Add icon and change the status of the offer. 1076 NGUI_SERV_FINANCIALS Service Financials tab Service Details screen Service Financials tab is not displayed. Present in read-only or view mode, unable to edit. Able to view the Add icon and change the status of the offer. 1077 NGUI_SERV_SIM_MSISDN Service SIM MSISDN tab Service Details screen Service SIM MSISDN tab is not displayed. Present in read-only or view mode. The icon to swap symbols is not available. Icon is displayed and allows swapping the SIM. 1078 NGUI_SERV_CONTRACTS Service Contracts tab Service Details screen Service Contracts tab is not displayed. Present in read-only or view mode. The icon to swap symbols is not available. Icon is displayed and allows swapping the MSISDN. 1079 NGUI_SERV_USAGE Service Usage tab Service Details screen Service Usage tab is not displayed. There is no edit option available in this tab, so it is always view-only. Screen will be similarly to 1 (View access). 1080 NGUI_SERV_HISTORY Service History tab Service Details screen Service History tab is not displayed. There is no edit option available in this tab, so it is always view-only. Screen will be similarly to 1 (View access). 1081 NGUI_SERV_LISTS Service Lists tab Service Details screen Service Lists tab is not displayed. Present in read-only or view mode, unable to edit. The Add Record option will be displayed and allows adding records. 1082 NGUI_UNIDENTIFIED_PAYMENTS Unidentified Payments Toggle Payments tab Search un-identified Payments toggle is not displayed in billing. 0 and 1 behaves similar (Not displayed). Able to view the unidentified payment toggle. 1083 NGUI_OPS_CHANGE_SERVICE_STATUS Service status change Menu Service Details screen Suspend option is not displayed. Able to view the 'Change to' option in the Kebab menu. Able to view the 'Change to' option in the kebab menu. 1084 NGUI_OPS_CHANGE_PRODUCT_OWNERSHIP Change Product Ownership Menu Service Details screen Service Product Ownership change option is not displayed in Kebab menu. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1085 NGUI_OPS_CREATE_NETWORK_ISSUE Network Issue Menu Service Details screen Network Issue option is not displayed in Kebab menu of service. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1086 NGUI_OPS_CREATE_ONE_OFF_CHARGE Create One-Off Charge Menu Service Details screen Create One-off Charge option is not displayed in Kebab menu of service. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1087 NGUI_OPS_RENEW_NOW Renew Now Service Details screen Create Renew now option is not displayed in Kebab menu of service. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1088 NGUI_OPS_RELOAD_DATA Reload Data Menu Service Details screen Service Reload Data option is not displayed in Kebab menu. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1089 NGUI_OPS_CHANGE_TO_POSTPAID Change To Postpaid Menu Service Details screen Service Change To Postpaid option is not displayed in Kebab menu. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1090 NGUI_OPS_CHANGE_TO_PREPAID Change To Prepaid Menu Service Details screen ServiceChange To Prepaid option is not displayed in Kebab menu. Able to view the option in the Kebab menu. Able to view the option in the Kebab menu. 1091 NGUI_OPS_ALLOW_OVERRIDE Price Override Action Override price during the order, from purchased product, or advice of charge. Price override option is not available in offer configuration screen, purchased product and advice off Charge table of cart page. 0 and 1 behaves similar (Not Available). Price override option is available in offer configuration screen, purchased product and advice off Charge table of cart page. 1092 NGUI_OPS_ALLOW_NEGOTIATION Price Negotiation Action Negotiate price during the order and from purchased product. Price Negotiation option is not available in offer configuration screen, purchased product. 0 and 1 behaves similar(Not Available). Price Negotiation option is available in offer configuration screen, purchased product. 1095 NGUI_BILL_PAYMENTS_OPS_PRINT_RECEIPT Billing payment Print Receipt Operation Print Payment Receipt. Payment Receipt menu option is not displayed. Payment Receipt menu option is not displayed. Payment Receipt menu option is displayed. 1096 NGUI_BILL_PAYMENTS_OPS_RESEND_RECEIPT Billing payment Resend Receipt Operation Resend Payment Receipt Resend Receipt menu option is not displayed. Payment Receipt menu option is not displayed. Resend Receipt menu option is displayed. 1097 NGUI_BILL_PAYMENTS_OPS_CANCEL Billing payment Cancel Payment Operation Cancel Payment Cancel Payment menu option is not displayed. Payment Receipt menu option is not displayed. Cancel Payment menu option is displayed. 1098 NGUI_BILL_PAYMENTS_OPS_TRANSFER Billing payment Transfer Payment Operation Transfer Payment Transfer Payment menu option is not displayed. Payment Receipt menu option is not displayed. Transfer Payment menu option is displayed. 1108 NGUI_BILL_DEPOSIT Deposits tab Billing screen Deposit tab is not displayed. Deposit tab is displayed and Transfer icon is not displayed. Deposit Transfer icon is displayed and allows initiating a deposit transfer. 1110 NGUI_SERV_SERVICE_tab Service tab Customer Services Service tab Service tab is not displayed. The Service tab and its child tabs are displayed, but nothing can be updated in the child tabs. Service tab and its child tabs are displayed, and all updates are allowed. 1111 NGUI_SERV_SERVICE_OVERVIEW Service Overview tab Service Overview tab under Service tab. Not applicable The Service Overview tab content is displayed, but nothing can be updated. Service Overview tab content is displayed, and updates within the tabs are also allowed. 1112 NGUI_CUST_LIST Customer Related List tab Customer table Details screen. Customer Related List tab is not displayed. Present in read-only or view mode, unable to edit. The Add/Update/Remove record option will be displayed and allows adding, updating, and removing records. 1113 NGUI_APPLICATION_LOGGING Application logging Application logging in CSR toolbar Settings screen. Application logging configurations will not be available. Able to view the logging configurations. Able to view and also perform modification to appliation logging configurations.

5.1.3. Field Level Security

Field level security values come from /customerSecurity (returns customer security data) and /partySecurity (returns contact security data) APIs.

Each field is associated with a security group.

Depending on the API response, the fields must be handled. Each field has a string value that defines the security access.

API response value example 1: "SG-Default:Mand-1" → Indicates that the field has the security group "Default", and it is mandatory (1).

API response value example 2: "SG-Development:Mand-0" → Indicates that the field has the security group "Development", and it is not mandatory (0).

5.1.4. Action Administration Security

Only the user assigned to an action can make changes to the action, however the system supports an “Administration” override that allows a supervisor to perform updates to an action already assigned to a different user. The main use case for this permission is to allow a team leader or Admin user to reassign an action from one user to another (to do user unavailability, sickness or workload).

This administration level setting is defined by setting the Access Level for each workgroup that the security profile has access to (it is anticipated that the team leader of a workgroup have a different security profile than the regular users within the workgroup that defines this additional admin option for the workgroup).

Note These Access Levels are defined using a binary bitwise approach, so the Access Level setting may be obvious to determine.

View of workgroup access settings via Configuration Studio:

View of workgroup access settings via Convergent Billing client:

5.2. Multi Language Support

The application is designed to support multiple languages. Translation functionality is implemented by reading language-specific translation files located in module-specific folders. The application comes with default English language translation files (en.json). However, it is strongly advised to generate translation files for other languages using the translation-schema.json in conjunction with the cc-generate-translations script. While it is possible to manually create translation files for other languages by copying the respective en.json files, the recommended approach ensures consistency with the translation schema and facilitates easier and more effective version control. With the recommended approach, only one schema file per language needs to be version controlled, as opposed to the primitive non-recommended approach that requires version control for multiple files.

5.2.1. Process Overview and Illustration

Let’s take an example where application is required to support three additional languages beyond the default English language. By following the provided guidelines, seamless integration of translations for required languages can be achieved. The working directory for following process is 'assets/config/i18n'.

Prepare Schema Files

Identify the API messages translations to be supported and categorise them under the ‘api-messages’ parameter of the translation-schema.json located in 'assets/config/i18n,' which is included in the application package. For more information of API messages translations, see Configuration for Translation of API Messages.

Identify the dynamic active translations to be supported and categorize them under ‘glossary’ parameter in their respective sections in translation-schema.json. For more information of all dynamic translations supported by the application, see Dynamic Active Translations Supported.

The next step is to identify the languages that the application needs to support. For example: Hindi (hi), Arabic (ar) and French (fr).

After identifying the required languages, copy the default translation-schema.json to language-specific schema files. For example:

translation-schema-ar.json (Arabic)

translation-schema-fr.json (French)

translation-schema-hi.json (Hindi)

Supply the translations in each of the language-specific translation files. For example, provide all Arabic translations in translation-schema-ar.json, French in translation-schema-fr.json, and Hindi in translation-schema-hi.json.

Run the Translation Generation Script

Utilise the cc_generate_translations script to generate language-specific translation files based on the prepared schema. Use the following command syntax:

cc_generate_translations --locale <locale_name> --schema-file <schema-file-name>

Example:

cc_generate_translations --locale ar --schema-file translation-schema-ar.json cc_generate_translations --locale fr --schema-file translation-schema-fr.json cc_generate_translations --locale hi --schema-file translation-schema-hi.json

Version Control

It is essential to version control all schema files to streamline collaboration and ensure consistency across releases. This includes version controlling the default English schema file (translation-schema.json) as well as the schema files for additional languages. This approach facilitates easier merging and updating of translation keys with each release.

With every release, add or modify translations in all the schema files and regenerate the translation files using 'cc_generate_translations' after carefully merging.

5.2.2. Dynamic Active Translations Supported

There are certain dynamically added fields or views that vary based on project configuration. The application supports the following dynamic active translations. These dynamic active translations should be provided in the 'glossary' parameter and categorised into designated sections. It is allowed to add and remove keys in this section based on required configurations. The name of the key should be the reference label in the respective configuration mode, and its value should be the translation for it in respective languages.

Section Name Configuration Mode Mapping Section Description OFFER_CATALOGS DA Table Catalog → Display Name This contains the translations of the offer catalogs. OFFER_CATEGORIES DA Table Category → Display Name This contains the translations of the offer categories. OFFER_SERVICE_ATTRIBUTE ProductSpecificationCharacteristic name serviceCharacteristic name This contains the translations of the offer and service attributes. FILTER_CATALOG DA Table Catalog Search Filters → Display Name This contains the translations of offer catalog search filters. GENERIC_CONFIGURABLE_TABLE generic-tables.config.json → COLUMNS → labelTranslationKey generic-tables.config.json → EXPANSION_FIELDS → labelTranslationKey This contains the translations of all the application tables configured using generic-tables.config.json . ACTION_TYPE_DEFINITION_FIELDS DA Table Action Type Definition Schema Type → Field Display Name This contains the translations of all the custom actions fields. ISSUE_TYPE_DEFINITION_FIELDS DA Table Issue Type Definition Schema Type → Field Display Name This contains the translations of all the custom issues fields. PAYMENT_METHOD_DEFINITION_FIELDS DA Table paymtd.dCustomerPaymentMethodSchemaType → Field Display Name This contains the translations of all the customer payment method fields. ISSUE_TYPES Issue Types Display Name This contains the translations of both core and custom issue types. MNP_CONFIG mnp.config.json → portInRequestDetails → portInRequestDetailsForm → title mnp.config.json → portInRequestDetails → portInRequestDetailsForm → fields → name mnp.config.json → portOutRequestDetails → portOutRequestDetailsForm → title mnp.config.json → portOutRequestDetails → portOutRequestDetailsForm → fields → name This contains the translations of MNP issue forms (assets/config/mnp.config.json). PDF_MAKE pdf-make-template.config.json → {{translationKeyName}} This contains the translations for all the translation keys defined in assets/config/pdf-make-template.config.json . CONTACT_VALIDATION_PROPERTY_LIST static.config.json → contactValidationConfiguration → contactPropertyList → displayName This contains the translations for the list of properties that appear in validation panel during contact validation. CONFIGURABLE_CUSTOMER_INFORMATION dynamic-forms.config.json → customerInformation → <tabName> → <formName> → title dynamic-forms.config.json → customerInformation → <tabName> → < formName> → fields → label This contains the translations for sections and fields defined in customerInformation view of dynamic-forms.config.json . CONFIGURABLE_CREATE_CUSTOMER dynamic-forms.config.json → createCustomer → NoTab → <formName> → title dynamic-forms.config.json → createCustomer → NoTab → <formName> → fields → label This contains the translations for sections and fields defined in createCustomer view of dynamic-forms.config.json . CONFIGURABLE_CREATE_CONTACT dynamic-forms.config.json → createContact → NoTab → <formName> → title dynamic-forms.config.json → createContact → NoTab → <formName> → fields → label This contains the translations for sections and fields defined in createContact view of dynamic-forms.config.json . CONFIGURABLE_CONTACT_INFORMATION dynamic-forms.config.json → contactInformation → <tabName> → <formName> → title dynamic-forms.config.json → contactInformation → <tabName> → <formName> → fields → label This contains the translations for sections and fields defined in contactInformation view of dynamic-forms.config.json . CONFIGURABLE_CONTACT_PREFERRED_COMMUNICATIONS dynamic-forms.config.json → contactPreferredCommunications → PreferredCommunicationsList → preferredCommunicationsForm → title dynamic-forms.config.json → contactPreferredCommunications → PreferredCommunicationsList → preferredCommunicationsForm → fields → label dynamic-forms.config.json → contactPreferredCommunications → PreferredCommunicationsList → preferredCommunicationsForm → tableViewSettings → dynamicTableSettings → <addButtonCaption,updateButtonCaption,cancelButtonCaption,tableTitle> This contains the translations for captions and fields defined in contactPreferredCommunications view of dynamic-forms.config.json . These are displayed in preferred communications table of contact settings tab. CONFIGURABLE_SERVICE_ADDRESS dynamic-forms.config.json → checkoutServiceAddress → Service Address → serviceAddressForm → title dynamic-forms.config.json → checkoutServiceAddress → Service Address → serviceAddressForm → fields → label This contains the translations for section and fields defined in checkoutServiceAddress view of dynamic-forms.config.json . CONFIGURABLE_SERVICE_TABLES dynamic-forms.config.json → serviceTables → <Section Name> dynamic-forms.config.json → serviceTables → Section Name → Table Name → title dynamic-forms.config.json → serviceTables → Section Name → Table Name → fields → label This contains the translations for section and fields defined in serviceTables view of dynamic-forms.config.json . CONFIGURABLE_BILLING_SETTINGS dynamic-forms.config.json → customerBillingSettings → Section Name dynamic-forms.config.json → customerBillingSettings → Section Name → <formName> → title dynamic-forms.config.json → customerBillingSettings → Section Name → <formName> → fields → label This contains the translations for section and fields defined in customerBillingSettings view of dynamic-forms.config.json . CONFIGURABLE_TAX_EXEMPTIONS dynamic-forms.config.json → taxExemptionsTable → Tax Settings → taxSettingsOptionsForm → title dynamic-forms.config.json → taxExemptionsTable → Tax Settings → taxSettingsOptionsForm → fields → label This contains the translations for captions and fields defined in taxExemptionsTable view of dynamic-forms.config.json . These are displayed in tax exemption table of billing settings tab. CONFIGURABLE_TAX_REGISTRATION dynamic-forms.config.json → taxRegistrationsTable → Tax Registration → taxRegistrationOptionsForm → title dynamic-forms.config.json → taxRegistrationsTable → Tax Registration → taxRegistrationOptionsForm → fields → label This contains the translations for captions and fields defined in taxRegistrationsTable view of dynamic-forms.config.json . These are displayed in tax registration table of billing settings tab. CONFIGURABLE_STATUS_CHANGE_REASON dynamic-forms.config.json → statusChangeReason → NoTab → customerChangeStatusForm → title dynamic-forms.config.json → statusChangeReason → NoTab → customerChangeStatusForm → fields → label This contains the translations for captions and fields defined in statusChangeReason view of dynamic-forms.config.json . BILLING_DYNAMIC_FIELDS billing-dynamic-fields-config.json → <AccountType> → fields → displayName For the Applied transaction table: For the translation of headers of dynamic characteristics displayed under the expanded accordion of the Applied transaction table, the translation key-value pairs under this section in the following format: Key: The key received from the backend under characteristics for appliedCustomerBillingRate will be mapped as the key. It should be transformed into space separated Pascal Case. Example: Received Key (from API): senderAccountNumber Translation Key (to be defined in translations): Sender Account Number This contains the translations for fields defined in billing-dynamic-fields-config.json . For the Applied transaction table: This contains translations for headers used in the expanded accordion of the Applied transaction table (path: Billing → Transactions → Applied transaction table). The dynamic key received under characteristics from the appliedCustomerBillingRate API can be mapped here to achieve translation. For example, if the API returns senderAccountNumber in characteristics, then the corresponding translation key-value pair needs to be defined under this section like: Sender Account Number : <translation> PAYMENT_METHODS DA Table Payment Method Details → Payment Method This contains the translations of all the Payment Method Types PAYMENT_METHOD_DETAILS_MESSAGES DA Table Payment Method Details → Validation Failure Message DA Table Payment Method Details → Success Message Format This contains the translations for the validation failure message and success message format as configured in Payment Method Details DA table. ISSUE_TYPE_SECTION_DISPLAY DA Table Issue Type Section Display → Section Display Name This contains the translation of all the sections as configured in Issue Type Section Field Display DA table.

5.2.3. Configuration for Translation of API Messages

The translation of API messages works by lazily loading the range-specific translation file based on the error message ID. For example, if an error with the code E83559 is received, the language-specific translation file in the range 83001-84000 is loaded.

assets,

└── i18n └── api-messages ├── 1-1000 │ ├── en.json │ ├── ar.json │ └── ... ├── 1001-2000 │ ├── en.json │ ├── ar.json │ └── ... ├── 2001-3000 │ ├── en.json │ ├── ar.json │ └── ... └── ...

The recommended method for providing API message translations is to include the API messages in the specified format within the 'api-messages' parameter of the translation-schema.json. Subsequently, 'cc_generate_translations' script can be used to automatically generate the translation files.

Translation Keys

The translation key for a message should be the actual message ID. For example, if the message ID is 501, the translation key would be E501. The translation keys for the cause and action of the message should be <messageId>-cause and <messageId>-action, respectively. For example, if the message ID is 501, the translation keys would be E501-cause and E501-action.

Message Parameters

If a message contains dynamic parameters, they should be added to the translation text at their respective positions. The parameter names should follow the naming standard described below.

Parameter Naming Convention

Parameters should be prefixed with the keyword "param" followed by their respective sequence number. For example, param1, param2, and so on.

The parameter names should be enclosed in single curly braces {}. Example translation text with parameters: "E83559": "The value {param1} of fields provided is invalid”.

Translating Message Parameters

Further translation of API message parameters is supported based on a flag called 'translate'. If the name of the parameter is suffixed with _translate, its further translation will be considered. For example, {param2_translate}.

Message Parameter Translations

The recommended method for providing API messages parameter translations is to include them within the ‘api-messages/message-parameters’ parameter of the translation-schema.json. The translation key for a message parameter will be the same as the error parameter received from Encompass.

Dynamic Parameter Interpolation and ICU Message Format

Dynamic parameter interpolation is used to substitute message parameters. The translation text supports the ICU message format. Configurator can use ICU message format syntax to specify how the parameters should be formatted in the translated message.

Note If API message translations are not available in their respective language files, the unaltered message received directly from the API will be presented.

5.2.4. Dynamic Parameter Interpolation

Using Dynamic Parameter Interpolation, the position of dynamic parameters can change in any statement.

Generally, different languages have different ways of framing sentences. From the below translation in Google Translate, see how the position of the number "100" gets changed in Arabic.

So, to handle these kinds of scenarios, dynamic parameter interpolation has been introduced in translation, where the position of a dynamic parameter is inside, {} as per language.

Note The parameters are enclosed in {}. DO NOT CHANGE THE PARAMETER KEYS .

5.2.4.1. Example in Customer Connect Checkout Page

English Translation

“AMOUNT_LEFT_AFTER_PAYMENT_MESSAGE”: “Amount left after payment { paymentAmount }”

Arabic Translation

“AMOUNT_LEFT_AFTER_PAYMENT_MESSAGE”: “{ PaymentAmount } المبلغ المتبقي بعد الدفع “

5.2.5. Pluralisation using ICU Message Format

ICU format allows us to create user-friendly texts that combine the use of different plural, gender, date, and time forms in one string, which will vary depending on different languages.

For example

Consider following translations:

English

This issue has {numberOfActions, plural, =0{no Overdue Actions} =1{1 Overdue Action} other{{numberOfActions} Overdue Actions}}

Hindi

इस समस्या में {numberOfActions, plural, =0{कोई अतिरिक्त क्रियाएँ नहीं हैं} =1{1 अतिरिक्त क्रिया है} other{{numberOfActions} अतिरिक्त क्रियाएँ हैं}}

French

Ce problème {numberOfActions, plural, =0{n’a pas d’actions en retard} =1{a 1 action en retard} other{a {numberOfActions} actions en retard}}

In each message, the placeholder {numberOfActions} is replaced by the actual number of overdue actions based on the pluralization rules of the respective locale.

Locale numberOfActions Translated Message English 0 'This issue has no Overdue Actions' English 1 'This issue has 1 Overdue Action' English 2 'This issue has 2 Overdue Actions' Hindi 0 'इस समस्या में कोई अतिरिक्त क्रियाएँ नहीं हैं' Hindi 1 'इस समस्या में 1 अतिरिक्त क्रिया है' Hindi 2 'इस समस्या में 2 अतिरिक्त क्रियाएँ हैं' French 0 'Ce problème n’a pas d’actions en retard' French 1 'Ce problème a 1 action en retard' French 2 'Ce problème a 2 actions en retard'

5.2.6. RTL Support

The Customer Connect client supports multiple display languages, and hence also supports languages with RTL writing systems, meaning they are read right-to-left, instead of left-to-right. The most prominent examples of RTL languages include.

Arabic: The official language in 26 countries, with 310 million speakers.

Urdu: The official language in Pakistan and India, with more than 101 million speakers.

Hebrew: The official language in Israel, with 9 million speakers.

Typically, in web applications supporting one of these languages, most UI components are reversed, meaning scroll bars, progress indicators, buttons, so on.

The dir (direction) attribute is used to set the base direction of text for display. This setting is essential to support languages that use right-to-left scripts.

Basic Structure for RTL

<!DOCTYPE html> <html dir=” rtl”> <head>

This simple addition to the HTML element will have the following effects throughout the rendered page.

Paragraphs and other blocks will be right aligned.

Bidirectional text will correctly flow from right to left.

Punctuation will appear in the correct place relative to the text.

Table columns will progress from right to left, and their contents will be right-aligned.

Input form fields will automatically start at the right, by default.

If we write the style sheet correctly, CSS will automatically mirror the layout.

It will set the direction of overflows.

Customer Connect has been designed to change to RTL orientation when CSR change the language dropdown available inside the user profile section.

Example: Customer Connect Purchase success page with both LTR and RTL support as follows:

5.2.6.1. Enabling RTL Support

The client configuration file includes a property direction that represents the direction to be used for the language selected. It can be either ltr or rtl (case sensitive) and is optional. If no direction property is provided, by default it will be considered as ltr for that language.

Parameter Configuration Description Sample "direction": <"ltr" |”rtl"> Language direction attribute optionally configured in the i18n locale options inside the static.config.json (path- ./assets/config/static.config.json). Defaults to “ltr” if not specified. "i18n": { "options": { "locale":"ar", "direction": "rtl" }, "options": { "locale":"en", "direction": "ltr" }, }

5.3. Introducing Direct Variables

The direct variables framework provides a way to create and manage variables that can be accessed and utilised across different form frameworks. These variables defined can be utilised in Dynamic Forms Framework, Issue Type Form Definition Framework, and Action Form Definition Framework. This framework is specifically designed to allow population of fields with data sourced from API(s) including dynamic drop-down options, as well as setting the values form fields making the workflow highly configurable.

Key Components of DV Framework:

Unique Reference: Each configuration within the framework is assigned a unique reference, which serves as the primary identifier for the variable. It ensures that each configuration can be distinctly recognized and accessed.

Direct Variable Name: In addition to the unique reference, there is a direct variable name which acts as a secondary identifier. The format for accessing a direct variable is as follows:

directVariables.<uniqueReferenceKey>.<directVariableName>

To use direct variables, the following parameters must be configured in the direct-variables.config.json file deployed with the Customer Connect application:

Parameter Description uniqueReferenceKey Each configuration within the framework is assigned a unique reference, which serves as the primary identifier for the variable. It ensures that each configuration can be distinctly recognised and accessed. Tip There can be multiple direct variables associated with one unique reference key i.e. multiple variables can be created using the response from same API. clearingContext This parameter facilitates the clearing of stored direct variable based on the application context. This determines when the direct variables will be cleared. Currently, the framework supports two clearing contexts: customer and contact. When the specified context changes or closes, the associated direct variables will be cleared. apiAttributes httpMethod : Specifies the type of HTTP method to be used for API calls. Currently, it supports only GET. requestUrl : Defines the API URL to be invoked. Note The request URL can be formed using certain contextual dynamic parameters defined in the table below. Dynamic parameters are enclosed within double curly braces ({{}}). Note For action form definition framework, this should not be specified if the direct variable is used for dependent fields where the value from one or more fields derives the value of other fields. processingCondition The processingCondition specifies the condition under which a particular direct variable will be processed or stored for access. It consists of two parameters: qualifier : Supports two options: endsWith or includes. The ‘includes’ qualifier checks if the API call contains the request URL matcher, while ‘endsWith’ verifies if the matched URL request ends with request URL matcher. requestUrlMatcher : Used to specify the matching URL request. The qualifier can be either "endsWith" or "includes", and it matches against the request URL. Note The processing condition is optional except when used in the action schema definition framework. If a processing condition is not specified, the API call will be made as specified in the requestUrl in apiAttributes. It is recommended not to provide a processing condition when it is certain that the respective API call will not be made by the application, such as in the case of custom tailored API calls, especially when direct variables are used to achieve control over dependent dynamic dropdowns. Tip The matcher request URL can be formed using certain contextual dynamic parameters defined in the table below. Dynamic parameters are enclosed within double curly braces ({{}}). In almost all the cases the requestURLMatcher are same as request URL defined in API attributes. storeAttributes The storeAttributes section defines the unique name for a list of direct variables under each configuration and specifies the JSON path to extract data from the API response. The extracted data will be stored against the specified variable name for further access. There are two types of direct variables supported: Normal Direct Variables: The variables whose options and initial value are only dependent on dynamic query parameters as defined in the request URL. The following attributes can be defined for normal direct variables: directVariableName : Variable name to be used for accessing the data stored from the API. valueJSONPath : Specifies the data to be extracted from the API response using JSONPath notation. initialValueJSONPath : Specifies the initial value that should be assigned to the field associated with the direct variable source. Note The initialValueJSONPath is only stored and applied if and only if the specified JSONPath query evaluates to only one result. Tip If a drop-down field needs to have an initial auto-assigned value in the event of only one drop-down option, then the valueJSONPath and initialValueJSONPath can have the same values. Special Direct Variables: The direct variables whose value is influenced by the selection of another form field. These are mainly used when the value of the field has to be derived based on another characteristic name from the same API. The following attributes can be defined for special direct variables: directVariableName : Variable name to be used for accessing the data stored from the API. dependentKey : The unique identifier of the form field name whose input or selection should influence the direct variable value. characteristicNamesJsonPath : The JSONPath to store the list of characteristic names. The storage of characteristic names should match the selection or input of the field identified by dependentKey. In case the characteristic names as returned from the API differ from the options available in the field, an optional characteristicNamesStorageMapping attribute can be provided. characteristicValuesJsonPath: The JSONPath to store the list of characteristic values corresponding to characteristic names in sequence. characteristicNamesStorageMapping : An optional field to specify the storage mapping of characteristic names.

Dynamic Contextual Variables Supported:

Application supports using following contextual dynamic parameters while forming the request URL Dynamic parameters are enclosed within double curly braces ({{}}).

Parameter Name Description selectedCustomerId Current customer ID in context. selectedContactId Current contact ID in context. selectedCaseId Current case ID in context. selectedIssueId Current Issue ID in context. preferredCurrency The preferred currency of the selected customer. operatorId The current logged in operator ID. purchasedProductLimit The nonCancelledPurchasedProduct limit as configured in static.config.json file. selectedCustomerType The customer type of the selected customer.

Note Other than the above predefined dynamic contextual parameters defined above, there are some more dynamic parameters exposed which depends on the framework of its usage. For more information, refer to the respective form framework documentation. For Example: The issue form definition, action form definition and payment form definition framework exposes all the field keys of current schema form.

Sample Direct Variable JSON configuration for customer payment methods:

{ "directVariables": [ { "uniqueReferenceKey": "paymentMethod", "clearingContext": ["customer"], "apiAttributes": { "httpMethod": "GET", "requestUrl": "paymentMethod?customerId={{selectedCustomerId}}&caseId={{selectedCaseId}}" }, "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": "paymentMethod?customerId={{selectedCustomerId}}&caseId={{selectedCaseId}}" }, "storeAttributes": [ { "directVariableName": "pmName", "valueJsonPath”: "$.paymentMethod[*].name", “initialValueJsonPath”: “"$.paymentMethod[*].name” }, { "directVariableName": "pmDescription", "valueJsonPath”: "$.paymentMethod[*].description", “initialValueJsonPath”: "$.paymentMethod[?(@.isPreferred==’True’)].description” } ] } ] }

Application interpretation of Above Configuration: -

The above configuration suggests to create two direct variables which can be accessed using directVariables.paymentMethod.pmName and directVariables.paymentMethod.pmDescription identifiers.

The value [customer] set for clearingContext suggests clearing the value of the direct variables on customer quit or switch.

Inside apiAttributes

The value GET of httpMethod suggests using HTTP GET.

The value paymentMethod?customerId={{selectedCustomerId}}&caseId={{selectedCaseId}} of request URL suggest to make an API call using specified request URL. The values of contextual dynamic parameters selectedCustomerId and selectedCaseId will be substituted by the application based on the current context before making the HTTP call. The call will be made if the specified direct variable is not stored yet.

Inside processingCondition

The value endsWith of qualifier suggests determining whether the API URL ends with specified requestUrlMatcher.

The value paymentMethod?customerId={{selectedCustomerId}}&caseId={{selectedCaseId}} of requestUrlMatcher suggests the application to match the API URL. If the match is found, then the application will store the specified directVariables for later access.

Note The processingCondition is defined mainly for performance reasons. There are certain API calls which are called by the application by itself. During those API calls if the processing conditions are met then the respective direct variables will be stored. The advantage of this storage is, when the direct variable is accessed, and it is already stored then the API will not be called again otherwise the API will be called again using apiAttributes to store and define the specified direct variables.

For Example: List paymentMethod API (paymentMethod?customerId=162730&caseId=501926) is called by the application as soon as a customer is opened. In this example, the processing condition is met, and the specified direct variables are stored. Suppose the direct variable is accessed while creating an issue then the API will not be called again rather the variables will be fetched from the application store.

Inside storeAttributes array, two direct variables are defined:

If directVariables.paymentMethod.pmName is used as data source for a drop-down field then the options of the drop-down will be the name of all the stored payment methods of the customer and also if any customer has just one payment method stored then the field will be auto assigned with that value.

The value pmName of directVariableName suggests creating a direct variable with specified name.

The valueJsonPath of $.paymentMethod[*].name suggests storing all the payment method names as returned by LIST paymentMethod API.

The optional initialValueJsonPath of $.paymentMethod[*].name suggests to define an initial value of this direct variable if there is just one payment method stored.

If directVariables.paymentMethod.pmDescription is used as data source for a dropdown field then the options of the dropdown will be the description all the stored payment methods of the customer and also the field will be defaulted auto assigned with the description of preferred payment method.

The value pmDescription of directVariableName suggests creating a direct variable with specified name.

The valueJsonPath of $.paymentMethod[*].description suggests storing all the payment method descriptions as returned by LIST paymentMethod API.

The optional initialValueJsonPath of $.paymentMethod[?(@.isPreferred==’True’)].description suggests auto assigning the initial value of the field with the description of preferred payment method.

5.3.1. Achieving Control Next: Managing Dependent Dropdowns

Direct variables can be used to achieve control over dependent dropdowns, when a user makes a selection in a given field (referred to as the "source field"), the options or values available in one or more other fields (referred to as the "dependent fields") dynamically update based on the selection in the source field. Imagine a form with multiple fields that change based on selections made in other fields.

Instant Updates: Selecting an option in one field (source field), immediately updates the options in related fields (dependent fields) to display only valid choices based on the initial selection, eliminating the need for page refreshes.

Domino Effect: One source field can control several dependent fields, and vice versa. Multiple fields can influence each other.

Layers of Control: Imagine a chain reaction. A field can be influenced by another, and then it itself influences yet another field, creating a chain of dependencies.

Clean Slate: Changing the selection in the source field clears all selections in dependent fields previously influenced by the initial choice, subsequently displaying new valid options aligned with the latest selection.

How It Works

Once the data source is configured as DV for a field, the application looks for the configured direct variable as specified in direct-variables.config.json. The application identifies the parent fields by looking at the dynamic query parameters defined in requestUrl in apiAttributes.

For example, if requestUrl is defined as:

referenceData?name=DA-accl.addr.dMapCountryState-{{country}}

The application identifies country as the parent field.

externalOutbound?apiname=voucherValidate&customerId={{selectedCustomerId}}&serviceName={{serviceNumber}}&voucherPin={{pin}}&voucherNo={{serialNumber}}

The application identifies selectedCustomerId, serviceNumber, pin, and serialNumber as parent fields.

Once the value of all the parent fields is defined or entered by the user, the application makes the API call by substituting the values of dynamic parameters as entered by the user or defined in the context of the application. An API call is made again when the value of any of the parent fields changes. The options (using valueJsonPath) or values (using initialValueJsonPath) of the child field change based on the response of the API. The child fields are also cleared once the value in any of the parent fields changes.

Note The dependencies must be explicitly specified for action schema type definition framework in “Action Field Dependency” DA table.

Example Use Case and Application’s Interpretation

Use case 1: Address Selection - State Depends on Country and City Depends on State

Consider the following field configurations:

Field Name Component Type Data Source Type Data Source country Dropdown RT accl.addr.COUNTRY state Dropdown DV directVariables.state.stateName city Dropdown DV directVariables.city.cityName

Corresponding Configuration in direct-variables.config.json:

{ directVariables: [ { "uniqueReferenceKey": "state", "clearingContext": [ "customer" ], "apiAttributes": { "httpMethod": "GET", "requestUrl": "referenceData?name=DA-accl.addr.dMapCountryState-{{country}}" }, "storeAttributes": [ { "directVariableName": "stateName", "valueJsonPath": "$.referenceData[0].referenceValue[*].displayName" } ] }, { "uniqueReferenceKey": "city", "clearingContext": [ "customer" ], "apiAttributes": { "httpMethod": "GET", "requestUrl": "referenceData?name=DA-accl.addr.dMapStateCity-{{state}}" }, "storeAttributes": [ { "directVariableName": "cityName", "valueJsonPath": "$.referenceData[0].referenceValue[*].displayName" } ] } ] }

Application’s Interpretation of the Fields Configured

Country:

The data source type "RT" and it’s value "accl.addr.COUNTRY" suggest populating the 'country' field dropdown from the reference type "accl.addr.COUNTRY".

State:

The data source type "DV" and it’s value "directVariables.state.stateName" suggest populating the 'state' field dropdown using the direct variable with uniqueReferenceKey of state and variableName as stateName.

The application looks for the corresponding variable defined in direct-variables.config.json.

Examining the requestUrl (referenceData?name=DA-accl.addr.dMapCountryState-{{country}}), the application identifies country as the parent field for the 'state' field.

When the user selects a country (example: India), the application makes the API call GET referenceData?name=DA-accl.addr.dMapCountryState-India and populates the state dropdown with all the states of India by extracting data using valueJsonPath.

If the user switches to a different country (example: Australia), the application makes another API call GET referenceData?name=DA-accl.addr.dMapCountryState-Australia and populates the state dropdown with all the states of Australia.

City:

The data source type "DV" and it’s value "directVariables.city.cityName" suggest populating the 'city' field dropdown using the direct variable with uniqueReferenceKey of city and variableName as cityName.

The application looks for the corresponding variable defined in direct-variables.config.json.

Examining the requestUrl (referenceData?name=DA-accl.addr.dMapStateCity-{{state}}), the application identifies state as the parent field for the 'city' field.

When the user selects a state (example: Delhi), the application makes the API call GET referenceData?name=DA-accl.addr.dMapStateCity-Delhi and populates the city dropdown with all the cities of Delhi by extracting data using valueJsonPath.

If the user switches to a different state (example: Haryana), the application makes another API call GET referenceData?name=DA-accl.addr.dMapStateCity-Haryana and populates the city dropdown with all the cities of Haryana.

Use case 2: Special Direct Variable - Selecting serviceType based on Service Name

Consider the following field configurations:

Field Name Component Type Data Source Type Data Source serviceType Text String (ReadOnly) directVariables.purchasedProducts.serviceType serviceName Dropdown Auto Complete Dropdown directVariables.purchasedProducts.serviceList

Corresponding Configuration in direct-variables.config.json:

{ "uniqueReferenceKey": "purchasedProducts", "clearingContext": [ "customer" ], "apiAttributes": { "httpMethod": "GET", "requestUrl": "purchasedProduct?limit={{purchasedProductLimit}}&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" }, "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": "purchasedProduct?limit={{purchasedProductLimit}}&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" }, "storeAttributes": [ { "directVariableName": "serviceList", "valueJsonPath": "$.purchasedProduct[*].serviceName" }, { "directVariableName": "serviceType", "dependentKey": "serviceName", "characteristicNamesJsonPath": "$.purchasedProduct[*].serviceName", "characteristicValuesJsonPath": "$.purchasedProduct[*].serviceType" } ] }

Application’s Interpretation of the Fields Configured

serviceName: (Normal Direct Variable)

The data source type "DV" and its value "directVariables.purchasedProducts.serviceList" suggest populating the serviceName field dropdown using the direct variable with uniqueReferenceKey of purchasedProducts and variableName as serviceList.

The application looks for the corresponding variable defined in direct-variables.config.json.

Examining the store attributes, the application, the application stores all the serviceNames as returned by purchasedProduct API and populates the serviceName drop-down with will all the top-level services of the customer.

serviceType: (Special Direct Variable)

The data source type "DV" and it’s value "directVariables.purchasedProducts.serviceType" suggest setting the value of the serviceList field using the direct variable with uniqueReferenceKey of purchasedProducts and variableName as serviceType.

The application looks for the corresponding variable defined in direct-variables.config.json.

Examining the store attributes.

The application stores the list of service names using characteristicNamesJsonPath. For example: [90212332 and 89202101].

The application stores the list of service types using characteristicValuesJsonPath. For example: [Wireless Service and IPTV service].

The dependent key of serviceName declares the parent field whose selection should influence the value of serviceType field.

As soon as as the user selects a serviceName, its corresponding value serviceType is set by the application. For example:

If user selects “90212332” as serviceName then the application will set “Wireless Service” as the value of serviceType field.

If user selects “89202101” as serviceName then the application will set “IPTV service” as the value of serviceType field.

5.4. Configuring Reference Data

Customer Connect leverages reference data types to enhance various functionalities within its User Interface screens. All these types are organised in JSON format within the <cc-root>/assets/config/reference-data.config.json file.

These reference data types are categorised based on the modules within Customer Connect where they are utilised. Common types are listed under the 'APP' section.

Example:

{ "APP": { "TYPES_REASONS_MAPPING": "DA-perestapi.imp.dAdjustmentTypeReasonMapping", "STORE_DETAILS": "DA-ordwflw.dStoreDetails", "RT_cam_COUNTRY": "RT-cam.COUNTRY", "RT_cam_CITY": "RT-cam.CITY" }, "BILLING": { "INVOICE_CYCLE": "CM-Invoice_Cycle", "REPORT_LEVEL": "RT-REPORT_LEVEL", "EVENT_TYPE": "RT-norm_wls.EVENT_TYPE", "EVENT_SUB_TYPE": "RT-norm_wls.EVENT_SUB_TYPE", "REFUND_REASONS": "RT-PAYMENT_REJECTED" }, "CASE": { "CASE_STATUS": "DB-Case_Status", "HOW_RECEIVED": "CM-How_Received", "CUSTOMER_TROUBLE": "CM-Customer_Trouble", "CM_YesNo": "CM-YesNo" }, "COLLECTIONS": { "STEP_SKIP_REASON": "RT-treatment.imp.STEP_SKIP_REASON", "TREATMENT_PROMISE_OUTCOME": "RT-TREATMENT_PROMISE_OUTCOME", "status": "RT-QUERY_STATUS", "RT_TREATMENT_INSTALMENT_PERIOD": "RT-TREATMENT_INSTALMENT_PERIOD" }, "CUSTOMER_SERVICE": { "CUSTOMER_CONCERNS": "CM-Customer_Concerns", "DEPARTMENTS": "CM-Departments", "ENTITLEMENT_CATEGORY": "RT-ENTITLEMENT_CATEGORY" } }

Upon logging into the application, these types are loaded.

There is a flexibility to modify the assignment of reference data types to specific keys by adjusting their values in the JSON file. Additionally, it is possible to provide an empty string if certain reference types are not required during the application startup.

Below is a table illustrating all the reference data types and the respective modules, flows, or screens where they are utilised:

Data Element Module (Used in) Usage (UI Flow) DA-perestapi.imp.dAdjustmentTypeReasonMapping Case Management Open Customer → Create Issue DA-ordwflw.dStoreDetails Delivery Installation Delivery Installation → Store pickup RT-cam.COUNTRY Application On load → refData API (customer information (B2B))(as query parameter) RT-cam.CITY Application Login → refData API (customer information (B2B))(as query parameter) RT-cam.DISTRICT Application Login → refData API (customer information (B2B))(as query parameter) RT-COMPANY_TYPE Application Login → refData API (customer information (B2B))(as query parameter) RT-api.imp.B2B_CUSTOMER_TYPE Application Customer Creation Login → refData API (customer information (B2B)) (as query parameter) On Success Customer Creation Retrieve. RT-api.imp.CUSTOMER_TYPE Application Contact Login → refData API (as query parameter) RT-TIME_ZONE Application Login → full refData API (in response) RT-perestapi.imp.CONTEXT Application Login → full refData API (in response) CM-Invoice_Cycle Dynamic forms Bill Cycle drop-down RT-REPORT_LEVEL Dynamic forms Report Level drop-down RT-norm_wls.EVENT_TYPE Customer Billing Login → Billing → Transactions tab filter RT-norm_wls.EVENT_SUB_TYPE Customer Billing Login → Billing → Invoice details → change list Login → Billing → Statement tab → charde list Login → Customer Overview → Transaction RT-PAYMENT_STATUS Customer Billing Login → Billing → Payment tab RT-PAYMENT_LOCATION Customer Billing Login → Billing → Payment tab CM-Payment_Type Customer Billing Login → Billing → Payment tab RT-perestapi.BALANCE_TYPE Customer Billing Login → Billing → Transaction tab RT-perestapi.ADJUSTMENT_TYPE Case Management Login → Open case panel → Account Adjustment RT-adjust.REASON Case Management Login → Open case panel → Account Adjustment CM-Approve_Reject Case Management Login → Case panel RT-DISPUTE_CLASSIFICATION Customer Billing Login → Billing → Dispute tab RT-DISPUTE_STATUS Case Management Login → Case panel RT-DISPUTE_RESOLUTION Case Management Login → Case panel RT-perestapi.DISPUTE_ADJUSTMENT_TYPE Case Management Login → Case panel CM-InvoiceFormat Customer Billing Login → Billing tab → Settings tab → Invoice Formats table AT-invxml.InvoiceDelivery Customer Billing Login → Billing tab → Settings tab → Invoice Formats table RT-INVXML.INVOICE_LANGUAGE Customer Billing Login → Billing tab → Settings tab → Invoice Formats table RT-ADDRESS_CHOICE Customer Billing Login → Billing tab → Settings tab → Invoice Formats table RT-INVXML.EMAIL_ADDRESS_CHOICE Customer Billing Login → Billing tab → Settings tab → Invoice Formats table RT-accl.cust.DISCOUNT_PLAN Customer Billing Login → Billing tab → Settings tab → Spend Settings drop-down RT-inv.DATE_OFFSET_UOM Application Applicable for whole application RT-INVOICE_PAYABLE_COMPANY Application Applicable for whole application RT-PAYMENT_DAY_PREFERENCE Application Applicable for whole application RT-PAYMENT_METHOD_GENERIC Checkout Offer → Proceed to Configuration → Cart CM-Currency Checkout Offer → Proceed to Configuration → Summary RT-perestapi.imp.VOUCHER_ID_TYPE Case Management Login → Case panel RT-perestapi.CUSTOMER_BILL_CATEGORY Customer Billing Login → Billing → Invoice tab CM-WrapCode Case Management Login → Case panel RT-PAYMENT_REJECTED Customer Billing Login → Billing DB-Case_Status Case Management Login → CSR Cases Login → Customer Cases CM-How_Received Case Management Login → CSR Cases Login → Customer Cases CM-Customer_Trouble Case Management Login → Opening an Issue CM-YesNo Application Applicable for whole application CM-Notification_Method Case Management Login → Opening an Issue Login → Issue → Troubleshoot update Issue CM-Convenient_Time Case Management Login → Opening an Issue Login → Issue → Troubleshoot update Issue CM-Time_Type Case Management Login → Opening an Issue CM-Frequency Case Management Login → Opening an Issue CM-Root_Cause Case Management Login → Open case panel → Troubleshooting Issue → Network Issue Details CM-IncidentLocation Case Management, CSR-notification Login → Opening an Issue Login → Issue → Troubleshoot update Issue Login → Toolbar notification CM-Contact_Number_Type Case Management Login → Opening an Issue Login → Issue → Troubleshoot update Issue CM-Action_Type Case Management Login → Opening an Issue CM-Work_Group Case Management Login → Opening an Issue CM-Issue_Type Customer History Login → Open Customer → Click on History tab CM-CustomerMaintReason Case Management Login → Create Case or Issue event CM-Escalation Case Management Login → Open a Issue on case panel → Click on Activity tab → Check the listing activity and there is a view/Edit attribute button CM-IncidentLocation Case Management, CSR-notification Login → Notification center → Incident tab Login → Case panel → Open or Create Issue CM-IncidentType CSR-notification Login → Notification center → Incident tab DB-Incident_Status CSR-notification Login → Notification center → Incident tab Login → Notification center RT-perestapi.imp.case.GlobalSrchFilters Case Management Login → In Global search select Case from second drop-down values RT-perestapi.imp.contact.GlobalSrchFilters Global search by contact Login → In Global search select Contact from second drop-down values RT-perestapi.imp.FILTER_ACTION_TYPE CSR-action Login → My Action Login → Workgroup RT-perestapi.imp.SEARCH_TAG Product Offer Login → Offers → Promotional Offers tab Login → Offers → Overview Offers tab RT-REFERRING_AGENT Order Configuration Applicable for order configuration flow RT-prod.PREV_SERV_DETAILS Order Configuration Applicable for order configuration flow RT-prod.ORDER_CLASSIFICATION Order Configuration Applicable for order configuration flow RT-PAYMENT_METHOD_GENERIC Checkout Offers → Proceed to Configuration → Cart RT-WORKFORCE.GEOGRAPHIC_AREA Order Configuration Applicable for order configuration flow RT-cam.COUNTRY Serviceability Login → Offers → Address Service Feasibility check CM-Customer_Concerns Case Management Login → Select Issue → Open case Panel CM-Departments Case Management Login → Select Issue → Open case Panel RT-ENTITLEMENT_CATEGORY Customer Service Login → Open Customer → Open any current product → Entitlement tab → Transfer unit RT-ACTIVITY_TYPE Application Applicable for whole application CM-Equipment_Type Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab RT-perestapi.imp.SALES_CHANNEL Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab Login → Open Customer → Open any Current product → Cancel service RT-wls_inv.VANITY_CATEGORY Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab RT-perestapi.imp.PRODUCT_INSTANCE_STATUS Customer Service Login → Open Customer → Open any Current product → Cancel Service RT-perestapi.imp.DOCUMENT_TYPE Customer Service Login → Open Customer → Open any Current product → Document tab → Document type RT-prodprice.cmn.CANCEL_REASON Customer Service Login → Open Customer → Open any Current product → Cancel Service → Reason Codes Login → Open Customer → Open any Current product → Change Plan → Reason Codes CM-ReasonForMaint Customer Service To get maintenance reasons codes RT-equip.INVT_MAINT_REASON Customer Service To get replacement reason codes DA-perestapi.dUIOrderReasonCodes-Child Offer|Add Customer Service Login → Open Customer → Open any Current product → Add child offer → Reason Codes DA-perestapi.dUIOrderReasonCodes-Change Plan|Add Customer Service Login → Open Customer → Open any Current product → Change Plan → Reason Codes DA-perestapi.dUIOrderReasonCodes-Change to Postpaid|Add Customer Service Login → Open Customer → Open any Current product → Change to Postpaid → Get reason codes configuration DA-perestapi.dUIOrderReasonCodes-Change to Prepaid|Add Customer Service Login → Open Customer → Open any Current product → Change to Prepaid → Get reason codes configuration DA-perestapi.dUIOrderCancelRC-Change to Postpaid|Remove Customer Service Login → Open Customer → Open any Current product → Change to Postpaid → Get reason codes configuration DA-perestapi.dUIOrderCancelRC-Change to Prepaid|Remove Customer Service Login → Open Customer → Open any Current product → Change to Prepaid → Get reason codes configuration DA-perestapi.dUIOrderCancelRC-Change Plan|Remove Customer Service Login → Open Customer → Open any Current product → Change Plan → Get reason codes configuration for Cancel Change plan DA-perestapi.dUIOrderReasonCodes-Service|Remove Customer Service Login → Open Customer → Open any Current product → Cancel Logical TLO DA-perestapi.dUIOrderCancelRC-Service|Remove Customer Service Login → Open Customer → Open any Current product → Cancel Service → Get cancellation reason code for Cancel Service DA-perestapi.dUIOrderReasonCodes-AddOn|Add Customer Service Login → Open Customer → Open any Current product → Addons tab → Change status → MAINTENANCE_REASON codes DA-perestapi.dUIOrderReasonCodes-Offer|Suspend Customer Service Login → Open Customer → Open any Current product → Addons tab → Change status Suspend plan → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Offer|Reactivate Customer Service Login → Open Customer → Open any Current product → Addons tab → Change status un-suspend plan → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-VAS|Add Customer Service Login → Open Customer → Open any Current product → VAS tab → Add VAS → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Device|Add Customer Service Login → Open Customer → Open any Current product → Device tab → Add Device → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Deposit|Add Customer Service Login → Open Customer → Open any Current product → Financials tab → Financials → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Topup|Add Customer Service Login → Open Customer → Open any Current product → Financials tab → Topup → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Discount|Add Customer Service Login → Open Customer → Open any Current product → Financials tab → Discount → Maintenance reasons codes DA-perestapi.dUIOrderReasonCodes-Equipment Select|Add Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab → Resource Selection Offers DA-perestapi.dUIOrderReasonCodes-MSISDN Swap|Default Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab → Resource Selection Offers DA-perestapi.dUIOrderReasonCodes-SIM Swap|Default Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab → Get Reason Code Data For MSISDN Swap DA-perestapi.dUIOrderReasonCodes-Child Offer|Replace Customer Service Login → Open Customer → Open any Current product → Addons tabs → Replace offer → Maintenance reason DA-perestapi.dUIOrderCancelRC-Child Offer|Replace Customer Service Login → Open Customer → Open any Current product → Addons tabs → Replace offer → Cancel Reason DA-perestapi.dUIOrderReasonCodes-Modify Offer|Default Customer Service Login → Open Customer → Open any Current product → Modify Offer → Maintenance reasons DA-perestapi.dUIOrderReasonCodes-Default|Default Customer Service Login → Open Customer → Open any Current product → SIM & MSISDN tab → Get Reason Code Data For SIM Swap Login → Open Customer → Open any Current product → SIM & MSISDN tab get Reason Code Data For MSISDN Swap DA-perestapi.dUIOrderReasonCodes-Any|Any Customer Service For Product Instance Replacements (remove and add new instance). Both Status Update and Attribute Change (Similar to the default return value, changes across different tabs/screens result in returning default generic reason codes). DA-perestapi.dUIOrderCancelRC-Any|Any Customer Service For Product Instance Replacements (remove and add new instance). Both Status Update and Attribute Change (Similar to the default return value, changes across different tabs/screens result in returning default generic reason codes). RT-treatment.imp.INSTALMENT_REASON Collection Login → Collection → RefData for Payment Arrangement Installment CM-ProdMaintSwapReason Resource Login → Open Customer → SIM &MSISDN tab → Get Reason Code Data For SIM Swap RT-perestapi.PRICE_TYPE Checkout Login → Offer → Proceed to Configuration → Cart RT-ChangeOwnership.REASON Case Management Login → Select change ownership Issue → Open case panel RT-inv.DATE_OFFSET_UOM Case Management Login → Select Issue → Expand Panel with Form CM-ProdMaintChOwnReason Customer Login → Select change ownership Issue → Open case panel RT-TAX_CLASS Contact Login → Create Customer → Update Customer from configuration RT-perestapi.imp.CONTACT_ROLE Customer Service Login → Open Customer → Customer info tab → Representative tab CM-TeamBranch Plugins Applicable for external plugins RT-ACTIVITY_TYPE Customer Service Login → Open Customer → Child Offer Replacement RT-perestapi.imp.AOC_ACTIVITY_TYPE Customer Service External Advice Of Charge RT-CUSTOMER_ACTIVITY_SOURCE Customer History Login → Open Customer → History tab → Activity tab → Get Activity Filter Data RT-CUSTOMER_ACTIVITY_TYPE Customer History Login → Open Customer → History tab → Activity tab → Get Activity Filter Data RT-perestapi.imp.CUSTOMER_ACTIVITY_SEVERITY Customer History Login → Open Customer → History tab → Activity tab → Get Activity Filter Data RT-inv.DATE_OFFSET_UOM Case Management Login → Select Issue → Expand Panel with Form RT-PAYMENT_DETAILS Checkout Login → Offer → Proceed to Configuration → Cart RT-prodprice.cmn.CANCEL_REASON Customer Service Login → Open Customer → Cancel Service from Serviceability CM-ReasonForMaint Customer Service Login → Open Customer → Maintenance Reason Code CM-OrderType Checkout Get Order Type RT-PRODUCT_INSTANCE_STATUS Customer Service B2B customer list RT-TAX_CLASS Checkout Cart → Payment tab → VAT type drop-down CM-CustomerRank Customer Login → Open Customer → Customer info → Overview tab → Credit rack RT-perestapi.imp.cust.GlobalSrchFilters Global Search Login → Global search for customer RT-perestapi.imp.NBA_DECLINE_REASON Customer Login → Dashboard → Load Customer RefData on Demand RT-perestapi.imp.resource.REUSE_TYPE Customer SIM Details Login → Open Customer → Open any Current product → SIM & MSISDN tab DA-perestapi.dIssueTypeReasonMapping Case Management Login → Case Panel → Troubleshooting Issue DA-perestapi.imp.dAccStatusOperations Customer Billing Login → Open Customer → Billing → Overview tab → Get account actions RT-cam.GRADE Application Applicable for whole application RT-api.imp.PERSON_TYPE Application Applicable for whole application RT-CONTACT_CLASSIFICATION Application Applicable for whole application RT-SEX Application Applicable for whole application RT-api.imp.ALL_CC_CUSTOMER_TYPE Application Applicable for whole application RT-NATIONALITY Application Applicable for whole application RT-RESIDENCY_STATUS Application Applicable for whole application CM-Industry Application Applicable for whole application RT-SPOKEN_LANGUAGE Application Applicable for whole application RT-VISA_TYPE Application Applicable for whole application RT-MARITAL_STATUS Application Applicable for whole application CM-Title Application Applicable for whole application RT-PERSON_STATUS Application Applicable for whole application RT-PROFESSION Application Applicable for whole application RT-WRITTEN_LANGUAGE Application Applicable for whole application CM-YesNo Application Applicable for whole application RT-PERSON_CONSENT_RESPONSE Application Applicable for whole application RT-SOCIAL_MEDIA_TYPE Application Applicable for whole application CM-Language_Spoken Customer Settings Billing→ Settings RT-perestapi.imp.DOCUMENT_TYPE Document To get the document type drop-down values CM-Status Customer history Login → Open Customer → History tab → Case history tab Login → Open Customer → History tab → Activity history tab RT-perestapi.imp.DOCUMENT_TYPE Document To get the document type drop-down values RT-wls_inv.MSISDN_POOL Reserve Number Login → Open Customer → Click on Reserved Number tab → Select MSISDN DB-Order_Status Product Order Get Order Status RefData RT-perestapi.CHILD_OFFER_TYPE Product Order Get Offer Filters For Orders RT-perestapi.imp.order.GlobalSrchFilters Global Search Login → Product order global search RT-Payment.DISCOUNT_REASON Application Applicable for whole application RT-PAYMENT_DETAILS Checkout Offer → Proceed to Configuration → Cart RT-Payment.WALLET_TYPE Application Applicable for whole application RT-treatment.imp.STEP_SKIP_REASON Collections Applicable for collection flow RT-TREATMENT_PROMISE_OUTCOME Collections Applicable for collection flow RT-QUERY_STATUS Collections Applicable for collection flow RT-TREATMENT_INSTALMENT_PERIOD Collections Applicable for collection flow RT-WORKFORCE.JOB_TYPE Delivery Installation Offer → Proceed to Configuration → Cart → Installation tab RT-WORKFORCE.JOB_DURATION Appointment Get Job Duration RefData RT-perestapi.imp.NOTIFICATION_METHOD Customer Billing Login → Open Customer → Billing tab → Open Invoice & Statement tab → Click on any Invoice kebab menu → Click on Resend Invoice Link → Pop-up came with multi drop-down values (all first/parent level values came threw this RT) RT-perestapi.imp.SMS_ADDRESS_CHOICE Customer Billing Login → Open Customer → Billing tab → Open Invoice & Statement tab → Click on any Invoice kebab menu → Click on Resend Invoice Link → Pop-up came with multi drop-down values (all the second/child level values came via this RT for SMS) RT-perestapi.imp.EMAIL_ADDRESS_CHOICE Customer Billing Login → Open Customer → Billing tab → Open Invoice & Statement tab → Click on any Invoice kebab menu → Click on Resend Invoice Link → Pop-up came with multi drop-down values (all the second/child level values came via this RT for Email)

5.5. Configuring Action Types

An action is created to manage workflows by an individual user or by workgroups. Action types can be configured using the Action Type Definition Schema Type, Action Field Dependency, and Action Type Function Mapping DA tables.

5.5.1. Configuring Action Type Attributes

The framework is controlled based on the DA configuration. So, once any changes are made by refreshing the CC UI it reflects and renders the UI accordingly. Action type attributes can be configured using the Action Type Definition Schema Type and Action Field Dependency DA tables.

To add a new action type attribute, Action Type Definition Schema Type DA table must be updated:

Log in to Business & Administration Studio.

Open the Action Type Definition Schema Type DA table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Action Type drop-down list, select the action type.

In the Field Sequence Number drop-down list, select the field number. Field number determines the order of the field display name in the Create Action panel.

Enter the Field Name. It specifies the apiKey (maps to the API definition of the Action type, specifically the Input/Output Access Key in the “API To CB Field Mapping” DA table) for the attribute.

Enter the Field Display Name. Used for displaying the attribute label on the UI.

In the Mandatory drop-down list, select ‘Yes’ to make the field mandatory, or select ‘No’.

In the Editable drop-down list, select ‘Yes’ to make the field editable in the create and edit action workflow or select ‘No’ to make the field read only in the update action.

In the Display Component drop-down list, select the component type.

In the Component Sub Type drop-down list, select the component sub type.

In the Data Source Type drop-down list, select the Data Source Type.

Data Source Type Description RT Reference Type DV Direct Variable AT Attribute type DA Derived Attribute CM Process Engine Class

In the Data Source drop-down list, select Data Source.

Note For Data Source Type value of “DV”, enter the value in the Data Source. For more information on the Direct Variable data source, see Introducing Direct Variables .

Enter the Aspect Ratio. Used to determine the width of the field on UI. The total width of row is divided into 12 units. For Each Field the min value is two and max value is 12.

Note The above steps define the UI layout for Action Types, however for the data to be saved (or retrieved for existing actions) appropriate API changes are required to map the Input or Output Access Key fields to Facts belonging to the Action Class. See Mapping Action UI Fields to API Fields for more details.

Action Type Definition Schema Type DA:

Display Component & Display Component Sub Type

The selection of the “Display Component” field will determine the allowed values for the “Display Component Sub Type” field. This drives the data type and format of the data contained within the field presented.

For example, selecting "Dropdown" in Display Component will show the available types of drop-down field styles available on the UI:

Selecting “Text” in Display Component will restrict the values of Display Component Sub Type available (note, some of these options apply data validation or formatting rules):

Data Source Type and Data Source

These fields drive the source location of the data available for selection or population within the action attribute.

For example, when selecting “RT” as the Data Source Type, the Data Source Field will present a drop-down containing all Reference Type names for selection. Additionally, users can utilise the search functionality to efficiently locate specific RT entries within the drop-down list.

When selecting “DA” as the Data Source Type, the Data Source Field will present a drop-down containing all Derived Attribute names for selection. Additionally, users can utilise the search functionality to efficiently locate specific DA entries within the drop-down list.

Note For DV Data Source Type, user must enter the value in the Data Source as “directVariables.<uniqueReferenceKey>.< directVariableName>” as described in Introducing Direct Variables .

Configs and their respective UI Display

Basic Scenario: User configures multiple attributes for the “Send Information” with different display components such as drop-down, text, radio button, and date. Fields with drop-down and Radio button are configured with the RT data source type and their corresponding Data source name. Few fields with mandatory, and few fields are configured with editable as yes.

Action Type Definition Schema Type DA table

After the above DA configuration is entered for the “Send Information” action type, the Customer Connect UI appears as below when this action type is used:

A horizontal divider is to indicate the static (Action Type, Workgroup and Assigned User fields are present for all action types) and dynamic attributes.

5.5.1.1. Document Support on Actions

To support associating documents to an action during Action creation, a specific configuration of the Derived Attribute table “Action Type Definition Schema Type” is required. To do this, the “Display Component” option of “Document” is required to be used.

For example, the Action Type “Approve Account Adjustment” is configured as below having a Field Name as “documents” and Display Component as “Document” which will allow for the Document Upload option while creating the Action.

Document Upload section that would appear while creating the Action:

5.5.2. Dynamic Data Configuration

The Dynamic form framework available as part of the Action Type module provides the capability to define the fields displayed on the UI (action type attributes) in configurable way. By updating the values in DA tables, field attributes such as adding or updating validators, enable or disable the field, label configuration of field and handling of field dependencies can be controlled as per project specifications.

The direct variable framework (Introducing Direct Variables) can be used to populate the fields with data sourced dynamically from API(s) including dynamic drop-down options, as well as auto-populating string, text, or date fields, making the screens and workflow highly configurable.

Note The initialValueJsonPath property of storeAttributes is supported in action form definitions.

5.5.2.1. Configuring Values from an API Response

To display values based on an API response, the “Data Source Type” can be configured as DV (Direct Variable) and the “Data Source” value as the unique path of the direct variables within the json (example, directVariables.<UniqueReferenceKey>.<directVariableName>)

Example 1: Adding a new drop-down component:

Display a new field on the “Collateral request” action type as “Test Service Type” with API key “serviceType”. Here, it is defined as an editable drop-down component. Display only service types that customer has purchased in the drop-down list.

Steps for Configuring the above scenario:

As displaying the data based on an API response, the data source type will be “DV” and the data source value will be the unique configuration made in the direct.variables.config.json file that contains API details to use. In the example above, the direct variable definition is as below:

direct-variables.config.json:

{ "directVariables": [ { "uniqueReferenceKey": "service", "clearingContext": ["customer"], "apiAttributes": { "httpMethod": "GET", "requestUrl": "purchasedProduct?limit=9999&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" // it can be any api or externaloutbound api }, "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": "purchasedProduct?limit=9999&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" }, "storeAttributes": [ { "directVariableName": "serviceTypes", "valueJsonPath": "$.purchasedProduct[*].serviceType" //Single Value returned in the dropdown with no initial value. }, { "directVariableName": "serviceIds", "valueJsonPath": "$.purchasedProduct[*].serviceName", //Multiple Value returned in the dropdown with no initial value. } ], "dependants": [] } ] }

The “selectedCustomerId” in the double curly braces {{}} indicates the dynamic parameter that gets replaced with the customer ID before making the API call.

API Response:

As the required service type data is available inside the purchasedProduct, the valueJsonPath is configured with the "$.purchasedProduct[*].serviceType". This allows the Direct Variable “serviceTypes” to capture this list. Similarly, the Direct Variable “serviceIds” will contain the list of service names from the same API.

As the data source path should be “directVariables.<uniqueReferenceKey>.<directVariableName>”, for the above example it will be “directVariables.service.serviceTypes”.

Note Dynamic parameters used within the configured URL currently support inbuilt parameters of selectedCustomerId (the current Customer ID), selectedContactId (the current Contact ID), selectedCaseId (the current Case ID), and selectedIssueId (the current Issue ID).

Action Type Definition Schema Type DA table:

Customer Connect UI:

For a customer with only a single subscribed service:

For a customer with multiple subscribed services (of different types):

Example 2: Adding an Initial (Default) value:

The Direct Variable definition allows an initial value to be populated based on the API data. By defining the “initialValueJsonPath” attribute, the variable is informed on what data to use. By extending the previous example, the following can be modified:

"storeAttributes": [ { "directVariableName": "serviceTypes", "valueJsonPath": "$.purchasedProduct[*].serviceType", // Multiple Value returned in the dropdown . "initialValueJsonPath": "$.purchasedProduct[0].serviceType" // Use first value returned as Initial value }, { "directVariableName": "serviceIds", "valueJsonPath": "$.purchasedProduct[*].serviceName" // Multiple Value returned in the dropdown with no initial value. } ]

This allows the first service type returned (“Wireless Service”) be the initial value, while the service ID list remains unpopulated.

5.5.2.2. Configuring Inter-Field Dependencies

The system can support a use case where the selection of “Field A” populates the values of “Field B” by calling an existing API which accepts the “Field A” parameter as input or by using an external outbound API by using DV (Direct Variable) Data source type.

The system also supports populating “Field N” based on the selection of multiple fields and vice versa (selection of a single field can populate the values for the multiple dependent fields). To define field dependencies, the system must be configured with the parent and child relationship in the “Action Field Dependency” DA table.

To add a new action field dependencies, the Action Field Dependency DA table must be updated:

Log in to Business & Administration Studio.

Open the Action Field Dependency table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Action Type drop-down list, select the action type.

Enter the Field Name, which needs to be the same as the Field Name configured in the Action Type Schema Definition Type table which will be the “driving” or “parent” attribute.

Enter the Child Attribute which needs to be the same as a Field Name configured in the Action Type Schema Definition Type DA which will be the populated or “child” attribute.

In the Dependency Rule Type drop-down list, select the dependency rule type. This indicates the type of action performed for the Child Attribute like data update or making editable or mandatory based on the parent attribute selection. Currently only “Data Update” is supported.

In the Dependency Rule Value drop-down list, select the dependency rule value. It contains different rule values and currently it supports HTTP_GET and DV values.

In the Dependency Rule Trigger drop-down list, select the dependency rule trigger. A text field to indicate the dependency rule trigger.

Example 1 - Parent-Child Dependency

As an example, populate the “state” values based on the “country” selection. To achieve this, associate the “country” field as the Parent and “State” field as the dependent field.

Action Type Definition Schema Type DA table:

Here the dependent field is configured with the DV data source type.

Action Field Dependency DA table:

The dependency rule has been configured as a http GET method type and the URL is defined as an API that takes the country as input and returns a list of States. As the API attributes are already mentioned in the Action Field Dependency DA table, no need to configure the "apiAttributes" portion of the variable in the direct-variables.config.json file.

direct-variables.config.json:

{ "directVariables": [ { "uniqueReferenceKey": "state", "clearingContext": ["customer"], "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": " referenceData?name=DA-accl.addr.dMapCountryState-{{country}}" }, "storeAttributes": [ { "directVariableName": "states", "valueJsonPath": $.referenceData[0].referenceValue[*].name" } ] } ] }

Note To access the values of the other fields, the dynamic parameter must match the apiKey (Field Name) column configured in the Action Type Schema Definition Type DA.

Customer Connect UI:

Example 2 – Multiple Parent Dependency

The system supports populating the dependent value based on the multiple parent field values, i.e., the selection of Field A and Field B populate the available Field C values. In this case example, populate the service date based on the selected values of service D and language fields.

Action Type Definition Schema Type DA table:

Action Field Dependency DA table:

From the above configuration we can observe the service Date is dependent on two fields, where both fields are passed into the API request and the service date is stored in the directVariables.externalService.ServiceDate variable.

direct-variables.config.json:

{ "directVariables": [ { "uniqueReferenceKey": "externalService", "clearingContext": ["customer"], "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": externalOutbound?apiname=getNextActionText&msisdn={{testServiceId}}&textLanguage={{text Language}}" }, "storeAttributes": [ { "directVariableName": "serviceDate", "valueJsonPath": "$.actionDate " } ] } ] }

Customer Connect UI:

Example 3 – Multiple Child Dependencies

Consider the previous example, however we now need to populate some service text and the service date on selection of service ID.

Action Type Definition Schema Type DA table:

Action Field Dependency DA table:

Here the action field dependency has been configured with multiple child attributes for the same parent field.

direct-variables.config.json:

{ "directVariables": [ { "uniqueReferenceKey": "externalService", "clearingContext": ["customer"], "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": externalOutbound?apiname=getNextActionText&msisdn={{testServiceId}}&textLanguage=English" }, "storeAttributes": [ { "directVariableName": "serviceDate", "valueJsonPath": "$.actionDate " }, { "directVariableName": "serviceText", "valueJsonPath": "$.actionText " } ] } ] }

Customer Connect UI:

Example 4 – Multiple Child Dependencies with Multiple Values

By extending the concepts in the previous example, the system can be configured to extract multiple selectable values for multiple fields based on a single input value.

For this example, the Service Types associated with the customer’s subscriptions (from the purchased product API) can restrict the service IDs based on the selected service type – using the content from the same API request.

Action Type Definition Schema Type DA table:

direct-variables.config.json:

{ "directVariables": [ { "uniqueReferenceKey": "service", "clearingContext": ["customer"], "apiAttributes": { "httpMethod": "GET", "requestUrl": "purchasedProduct?limit=9999&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" // it can be any api or externaloutbound api }, "processingCondition": { "qualifier": "endsWith", "requestUrlMatcher": "purchasedProduct?limit=9999&offset=0&customerId={{selectedCustomerId}}&includeStatus=Non-Cancelled" }, "storeAttributes": [ { "directVariableName": "serviceTypes", // for serviceType Field "valueJsonPath": "$.purchasedProduct[*].serviceType" }, { "directVariableName": "serviceIds", // for serviced field "valueJsonPath": "$.purchasedProduct[*].serviceId" } ] } ] }

From the above example, it is observed that the system can be configured with multiple store attributes from single API response and populate the values for multiple different fields. It is also possible to filter the values of Field B without making an API call again when both Field A and Field B are populated from the same API response.

Note Here Dependency Rule Value must be configured as DV.

Action Field Dependency DA table:

Customer Connect UI:

Initially it will display all the service IDs, but on selection of the service type the list of service IDs will be filtered based on the selection:

5.5.3. Mapping Action UI Fields to API Fields

The Action Type Function Mapping DA table contains the mapping for customizable functions to each action type and API operations. The Attribute derivation function field derives various attributes (facts) values before the main API commits the action to DB, whereas the optional Post-processing function field is called after committing to finalize action creation or modification.

To map action type function:

Open the Action Type Function Mapping DA table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Action Type drop-down list, select the action type.

In the Action drop-down list, select the action.

Enter the Attribute Derive Function Name.

Enter the Post Processing Function Name.

Action Type attributes will be passed in the API request as part of the characteristic object. The project teams must create entries for additional action type attributes in the API to CB Field Mapping DA table for POST/PATCH/GET Action, POST/PATCH Issue, and PATCH/GET Case APIs.

5.5.4. Configuring Action Types in the Case Panel

A user can create new actions from the Case panel to capture specific activities required to service a customer request. The action types available for selection can be configured based on the security profile of the user.

Additionally, a “quick list” of action types is available in the Case panel menu, where the first five action types configured for the user profile appear within the menu itself.

The available action types for a user security profile are defined within the Derived Attribute Table “Profile Action Type”, which defines which “User Profiles” can create which “Profile Action Type”, and what the presentation order is. Note that this table supports a “Default” profile, such that a set of action types will be presented for all profiles not specifically defined. This “Default” set of action types will be “merged” with any specific action types defined for a specific security profile, i.e. if a security profile has a combination of action types defined for the “Default” profile as well as others, the presentation order will first order all action types specifically defined for the profile in sequence number order, then append the “Default” profile action types in sequence number order – filtering out any overlapping entries.

For example, the following figure shows specific rows for the DEVELOPER profile which will be merged with the “Default” list of action types – which in the ordering logic described above will be presented as – Bill Analysis, Campaign Call Back, Follow Up Call, Investigate Payment, Collateral Request, Customer Service Call Back, Send Information, and Trouble Follow-up. The first five action types in this list will appear in the “quick list” in the case menu.

Note The “Default” profile mentioned here is given as **Default** profile in the Derived Attribute Table to avoid confusion with any other existing profile named “Default”. The action types for the “Default” profile map to ALL profiles in the system. The rows defined for specific security profiles effectively override and are merged with the “Default” set. The attribute Type perestapi.ProfileActionType contains the set of action types available for creation from the Case panel. If new action types are created and are to be available for a user to create manually (many are to be created ONLY by workflow processes), the SQL query within the attribute type should be modified.

5.5.5. Configuring Overrides for fields when Creating an Action

The system supports overriding the initial values of certain fields on Actions that would normally be “hard configured” based on the Action Type. The default set of fields that can be configured to be overridden are:

Duration

Workgroup

Escalation Policy

On creation of an Action, a deployment-configurable function cm.imp.actionOverride& is invoked which is used to override these fields. This function can be extended to provide additional or alternative override fields or logic.

Examples of the supported configuration overrides:

Table Column Description Action Type ( Mandatory ) List of action type available in the system. Override Duration – Hours ( Optional ) Configure the duration in hours for action type due date. Override Workgroup ( Optional ) Configure the available workgroup from the list for the action type. Override Escalation Policy ( Optional ) Configure the available escalation policy from the list for the action type.

Any values not populated in the above table will not be overridden and hence will use the definition supplied by the Action Type itself.

5.5.6. Security Permissions for Actions

Only the user assigned to an action can make changes to the action, however the system supports an 'Administration' override that allows a supervisor to perform updates to an action already assigned to a different user. For more information on how to configure this access, see Action Administration Security.

5.6. Configuring User Profile Case Type Mapping

Different types of Cases can be configured using the User Profile Case Type Mapping table and the Case_Type class.

To add a new case type, Case_Type class must be updated:

Open the PE Configuration Workbench.

Open the Class and Data Tool.

In the left-hand side panel, within the Current tab, proceed to scroll down to the Case_Type class and click to open it on the right-side display panel.

In the Case_Type class, select the Data tab.

Once the data grid is visible, click the Lock icon on the panel menu above to unlock the entity and make it editable.

Click the latest added row in the data grid, then press the down arrow to create a new row for adding a case type based on the requirements.

Ensure that the 'Name' of the newly added case type consists of a single character. The 'Display Name' can be added according to the specified requirements.

Click the green tick icon, which is also the Save icon.

A message pop-up window will appear to indicate successful commit of the newly added case type.

This case type can now be found while updating the User Profile Case Type Mapping DA table.

To add a new case type mapping attribute, the User Profile Case Type Mapping DA table must be updated:

Log in to Business & Administration Studio.

Open the User Profile Case Type Mapping table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the User Profile drop-down list, select the user profile.

In the Case Type drop-down list, select the case type.

Click the Tick Mark icon to save the changes.

The case type will be determined by the API for the user profile provided in the following ways for different scenarios:

If a case type is provided in the API, that will be the case type assigned irrespective of the mapping provided in the DA table.

If a case type is not provided in the API:

If the mapping for the user profile is available on the DA table, the case type will be displayed accordingly.

If the mapping for the user profile is not available on the DA table, the case type will be displayed as ‘C’ by default.

If the DA table does not exist, the case type will be displayed as ‘C’ by default.

5.7. Configuring Case/Issue Reopening Restrictions

Customer Connect supplies the ability to restrict the reopening of cases/issues after a certain period has passed. This period depends on the source location of the request. For example, a Case may be reopened within 5 days of it being closed if the request comes from the Customer Connect UI client, but may be restricted after 2 days if the requesting source is a mobile phone application.

Each source application expected to request reopening a case (via the API api.imp.fPERestPatchCaseExecuteOperations&()) and for reopening an issue (via the API api.imp.fPERestPatchIssueExecuteOperations&()) should be configured within the reference type perestapi.imp.SOURCE_LOCATION.

For each SOURCE LOCATION, add a row in reference type perestapi.imp.SOURCE_LOCATION.

To configure perestapi.imp.SOURCE_LOCATION:

Log in to Business & Administration Studio.

Click the Lists from the Reference Data menu.

Search the perestapi.imp.SOURCE_LOCATION reference type.

Open the perestapi.imp.SOURCE_LOCATION reference type.

Click the Edit icon to edit the reference type.

Click the + icon to insert a new row. Code ID is auto assigned if a new row is added to the reference type.

Enter the Code Label.

Enter the Display Label.

Enter the description.

Enable the SOURCE LOCATION.

Select the Child List from the drop-down list depending on the requirement.

Select the Child Attribute Type from the drop-down list depending on the requirement.

Click the Tick Mark icon to save the changes.

Source Location to Days Offset mapping can be retrieved using the ‘Source Location to Days Offset Mapping for Issues/Cases’ filter.

To configure source location filters:

Log in to Business & Administration Studio.

Open the Source Location to Days Offset DA table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Source Location drop-down list, select the Source Location.

In the Flow Type drop-down list, select the Flow Type.

In the Issue Reason Type drop-down list, select the Issue Reason Type, for Flow Type – Case the Issue Reason Type should be null.

In the Days Offset field, enter the number of days (i.e., the case/issue cannot be re-opened this number of days after it is closed.)

Note If DA perestapi.dReOpenOffset is not configured for case/issue as a default behaviour. The Case will be allowed to be reopened. The Issue will not be allowed to be reopened.

5.8. Capturing Issue type on Case Closure

Summary

Capturing issue draft at case closure to identify the calling reason while CSR lands from external applications to Customer connect. The check for verifying if CSR has created the draft for the required issue type is executed when there is an attempt to close the case.

Note Configuration for this functionality will only work for CSR accessing Customer Connect from redirect utilities.

5.8.1. Configuration

"redirectUtilities": { "searchCustomer": { "key": { "msisdn": { "mandatoryValidation": false, "draftIssueType": "Billing Enquiry", "draftIsMandatory": true } } }, "searchContact": { "key": { "name": { "mandatoryValidation": false, "draftIssueType": "", "draftIsMandatory": false } } } }

Configuration in static.config.json under redirectUtilities can drive the exit check and ask CSR to capture the required draft.

draftIssueType:

This can hold value as string for issue draft type that needs to be captured.

Issue type can be configured in draftIssueType property listed below:

For Customer: redirectUtilities > searchCustomer > key > msisdn > draftIssueType

For Contact: redirectUtilities > searchContact > key > name > draftIssueType

Supported Values:

One-off Charge

Account Adjustment

Dispute

Troubleshooting

Troubleshooting:change_hardware

Voucher Discharge

Customer Maintenance

Billing Enquiry

Customer Service

Change Ownership - Friendly

draftIsMandatory:

Boolean value can be declared here to control execution of check at case closure.

true: CSR cannot exit the case until draft is created.

false: CSR can continue the normal flow without any interruption.

5.9. Asset Configuration files for Angular GUI

The configuration files for Angular GUI are stored in the assets/config folder path in the build package.

Main configuration files are stored in the path <cc-root>/assets/config:

Note Refresh the browser to restart the application.

Static Parameter configuration file: The static parameter configuration provide customisation of various feature toggles, feature settings and options and will affect all the users (sessions) logged in to the application. All the recommended static configurations are stored in static.config.json file. For more information, see Static Parameter Configuration.

Dynamic Forms configuration file: The Dynamic Form framework provides the capability to configure racks, sections, and forms in a dynamic way. To configure these, need to manipulate the dynamic-form.config.json file. It offers flexibility to control fields by adding or updating validators, enabling or disabling fields, configuring labels for racks, showing or hiding fields, handling field or rack dependencies, and utilising the rendered form in relation to the table, among other features.

Also one can create re-usable jsons under <cc-root>/assets/config/schemas directory and refer them in dynamic forms configuration file.

For more information, see Dynamic Form Framework in Configurability Framework Guide.

Billing Dynamic Fields configuration file: Billing dynamic fields configuration provides the configuaration for prepaid account and other account billing widget.

For more information, see Billing Widget Configuration in Configurability Framework Guide.

Direct Variables configuration file: The direct variables framework provides a way to create and manage variables that can be accessed and utilised across different form frameworks. These variables defined can be utilised in Dynamic Forms Framework, Issue Type Form Definition Framework, and Action Form Definition Framework. This framework is specifically designed to allow population of fields with data sourced from API(s) including dynamic drop-down options, as well as setting the values form fields making the workflow highly configurable. For more information, see Introducing Direct Variables.

Generic Tables configuration file: Generic tables configuration file provides more flexibility like:

To change the column with value.

Enable or disable the sorting.

For more information, see Generic Table Framework in Configurability Framework Guide.

PDF Make Template configuration file: The modules or features which require a document generation process should have their respective unique configuration key in the file.

For more information, see PDF Generation Framework.

Script configuration file: Script configuration file used to configure analytics related configurations. For example Raygun config, Analytics, and more.

For more information, see Script Parameter Configuration.

Serviceability configuration file: Address Serviceability can be configured using configuration file.

For more information, see Configure Address Serviceability.

UoM configuration file: UoM configuration file provides all conversion logics between different UoM’s for converting values between different Unit of Measure added to the UI.

For more information, see UoM Conversion.

MNP Parameter configuration file: MNP parameter configuration used to configure the MNP fields on the Issue screen and New sales order screen.

5.10. Configuring Themes

Configuration of Themes

The theme will determine how the colors and text styling are applied to the application. Customer Connect has the following four themes and there is provision to add new themes too:

theme-digico(Default Theme)

theme-green

theme-blue

theme-light

Changing the application Theme

Customer Connect will have theme-digico as the default theme, however, it can be changed using applicationTheme property in static.config.json file.

The following names can be used as a value of applicationTheme property.

Theme Name Usage in static.config.json theme-digico "applicationTheme" : "theme-digico" theme-light "applicationTheme" : "theme-light" theme-green "applicationTheme" : "theme-green" theme-blue "applicationTheme" : "theme-blue"

Adding new Theme

A new theme can be added to Customer Connect by providing color configurations as a JSON file, placing it under <CC Root>/assets/config/themes folder, and using the file name (without the extension) as applicationTheme property in <CC Root>/assets/configstatic.config.json file.

The following colors can be specified in the theme file:

Type Variations Property Name Primary Base primary-base Dark primary-dark Darker primary-darker Light primary-light Lighter primary-lighter Secondary Base secondary-base Dark secondary-dark Light secondary-light Lighter secondary-lighter Neutrals 100% dark-scale-100 90% dark-scale-90 80% dark-scale-80 70% dark-scale-70 60% dark-scale-60 54% dark-scale-54 50% dark-scale-50 40% dark-scale-40 30% dark-scale-30 20% dark-scale-20 15% dark-scale-15 12% dark-scale-12 10% dark-scale-10 5% dark-scale-5 2% dark-scale-2 0% dark-scale-0

Note Default theme-digico colors will be overridden using the colors specified in the theme file. Depending on the requirement, it can override only selected color pallets (Primary, Secondary, Neutrals, etc) and let the system use default colors for other properties in theme-digico .

Default theme-digico has the following colors, when creating a theme, consider the brand colors and use color theory to choose neutral colors and their variations:

Example :

Properties Example Values Theme Name theme-dark Theme File Name theme-dark.json File Location <CC Root>/assets/config/themes/ File Content { "name": "darkTheme", "primary-dark": "#ff6f00", "primary-base": "#ff8f00", "primary-light": "#ffc107", "primary-lighter": "#ffe082", "secondary-dark": "#2f3246", "secondary-base": "#545871", "secondary-light": "#a9abb8", "secondary-lighter": "#d4d5db", "dark-scale-100": "#F2F2F2", "dark-scale-90": "#D9D9D9", "dark-scale-80": "#BFBFBF", "dark-scale-75": "#B3B3B3", "dark-scale-70": "#A6A6A6", "dark-scale-60": "#999999", "dark-scale-54": "#8C8C8C", "dark-scale-50": "#808080", "dark-scale-40": "#737373", "dark-scale-30": "#666666", "dark-scale-20": "#595959", "dark-scale-15": "#4D4D4D", "dark-scale-12": "#404040", "dark-scale-10": "#333333", "dark-scale-7": "#2D2D2D", "dark-scale-5": "#262626", "dark-scale-3": "#202020", "dark-scale-2": "#1A1A1A", "dark-scale-0": "#000000", "color-success-dark": "#075533", "color-success": "#0b794b", "color-success-light": "#1eab6e", "color-success-lighter": "#e5f5ed", "color-error-dark": "#8b1d1e", "color-error": "#be2728", "color-error-light": "#d9494a", "color-error-lighter": "#ffebeb", "color-warning-dark": "#995e0b", "color-warning": "#d97400", "color-warning-light": "#f3b65b", "color-warning-lighter": "#fdf7e2", "color-info": "#0d66d0", "color-info-light": "#0097ff", "color-info-lighter": "#e3f2ff", "color-info-dark": "#0d40a5" }

5.11. Raygun Configuration

Raygun provides actionable real-time insights into the quality and performance of the application. It helps to detect, diagnose, and resolve issues quickly to deliver an enhanced digital experience to customers.

The features of Raygun:

Error Monitoring and Crash Reporting - provides insights about the application health in real-time and monitors the errors and application crashes with in-depth details of each error.

Real User Monitoring - keeps track of the user sessions. Creates a timeline of important information that can help the dev teams to extract reports from the application.

Raygun Integration

To integrate Raygun with an Angular application, see Angular Integration.

Enabling Raygun Analytics

To enable Raygun analytics, the analytics-config.js (path - ./assets/config/analytics-config.js) file must be configured.

window['customer_connect_global'] = { enableAnalytics: false, raygunKey: '' };

raygunKey - Enter the API key from the Raygun.

enableAnalytics - Set it to true to enable the analytics.

For more information about using Raygun web console, see Raygun product guide.

5.12. PDF Generation Framework

The modules/features which require a document generation process should have its respective unique configuration key in the file.

PRODUCT_ENQUIRY document PDF document generation is supported.

A JSON compliant static configuration file is added: /assets/config/pdf-make-template.config.json

The main configuration is divided into two:

Document Definition

The document definition follows pdfmake configuration with some custom extensions to allow for easier configurations:

The configurations for document definition, see PDFMAKE.

Playground can be used to try out document definition configurations.

Following are certain custom extensions added to complement pdfmake default configurations:

Loading of images from /assets/images directory:

The images can be added to the PDF document by adding data uri of the required image.

Furthermore, images can be placed in /assets/images directory and the same can be referred by name in the document definition object. Customer Connect will ensure automatic loading of the images.

For Example:

"images": { "header-logo": "logo.png" },

This case, logo.png must be present in assets/images directory and will be automatically loaded by Customer Connect.

Custom content replacement. Each module/feature shall have its own custom content dynamically generated by Customer Connect. The placement of the custom content can be configured.

Multi-language support is added to the PDF document.

The PDF document will be generated based on the locale selected by the CSR.

The text to be replaced by using translation files shall be added as a key in the locale specific translation files(/assets/i18n/glossary/<locale>.json) and must be enclosed in {{}}.

Certain dynamic parameters are exposed which, if used, will be replaced in translation text. This works the same way as dynamic parameter interpolation in multi-language translations.

The following are the dynamic parameters supported:

Parameter Name Related Module/Key Description currentDateTime All The current date and time of PDF document generation in "DD MMM YYYY hh:mm:ss A" format. currentDate All The current date of PDF document generation in "DD/MM/YYYY" format. currentYear All The current year of PDF document generation in "YYYY" format. currentTime All The current time of PDF document generation in " hh:mm:ss A" format. currentPage All - Can only be used in footer section The current page of PDF document in context. pageCount All - Can only be used in footer section The total number of pages generated for the PDF document orderId PRODUCT_ENQUIRY The created product enquiry order name. caseId PRODUCT_ENQUIRY The current case name. partyName PRODUCT_ENQUIRY The name of the association party with the created product enquiry order. This will carry the name of the contact if the enquiry is generated for a contact. This will carry the name of the customer if the enquiry is generated for a customer.

Document Extras

The Document Extras contain the module-specific characteristics used for PDF generation. Following is the explanation of the options supported.

option Description translatableKeys This contains the list of translatable keys specific to the sections defined in document definition. Its corresponding translation text is expected to be present in locale specific translation files (/assets/i18n/glossary/<locale>.json). Only the keys defined here will be replaced with the content from translation files. These keys are referenced in document definition enclosed in {{}}. For example: replaceContentIndex The index in the content array of document definition where the custom module specific content shall be replaced. fontsByLocale This contains the list of fonts that will be loaded based on locale selected in Customer Connect. If multiple locales are configured to be supported then there must be explicit list of fonts configured for each locale. The font files must be present inside /assets/fonts directory. Note The fonts must be carefully configured. Not all fonts are designed to support multiple languages. For Example: If "en" locale is selected in the application then all the fonts which are defined for "en" will be loaded. Similarly, if "ar" locale is selected in the application then all the fonts which are defined for "ar" will be loaded. Fonts for all four text formatting viz. "normal, bold, italics, bolditalics" must be configured. Though they can be same for different formatting. For example, bold and bolditalics formatting can use the same font. The font key defined here shall be used in document definition. For instance, if font "noto_sans" is used for certain content in document definition then, If "en" locale is selected, NotoSans-Regular.ttf will be applied for normal formatted text. If "ar" locale is selected, NotoSansArabic-Regular.ttf will be applied for normal formatted text. For a content having mix of characters from multiple languages shall use the font which supports the scripts of all those languages. It is strongly recommended that the font configured in "defaultStyle" of document definition shall support all the configured languages. The custom content dynamically generated by the application will be using this font. For example: Consider below configuration, the font "amiri" is used for custom content. This font supports both english and arabic scripts. customContentProperties This contains the properties that are applicable to the custom content dynamically generated by the application. This shall have different attributes for different modules. Following are the attributes for the generation of PRODUCT_ENQUIRY ColorsByLevel : This contains the list of colors that will be applied at each level of hierarchy while generating the pricing table for product enquiry. A number of levels is dependent on the offer structure configured in Encompass. It is recommended to define at least 8-10 colors. For example: In below generated product enquiry document snapshot, it can be observed that each level is indented with a certain margin applied to the left and the colors generated for each level are as per the configuration. tableLayout : The predefined table layout. This can have one of following values: "noBorders"(default): Renders the table without borders and without horizontal padding for the left- and right-most cell. "headerLineOnly:": Only renders a horizontal border below the rows marked as header. "lightHorizontalLines": Renders gray horizontal borders.

5.13. UoM Conversion

Support for converting values between different units of Measure added to the UI. The new configuration file introduces the ability to keep all conversion logics between different UoM’s.

5.13.1. UoM-Conversion.json

This file will be available on the following path:

<CC_Home>/assests/config/uom-conversion.json>

The user can add/edit UoM conversions to this file.

Note The user has to specify the base unit, and the base unit should have a multiplier of 1. All other unit multiplier values will be relative to the base unit.

The configuration in the following example byte is set as the base unit, and all other unit multipliers are relative to that.

Unit Multiplier Base Unit byte 1 yes kilobytes 1024 megabytes 1024 * 1024 gigabytes 1024 * 1024 * 1024 terabytes 1024 * 1024 * 1024 * 1024

5.14. PE Configuration

5.14.1. Customer Maintenance Issue Creation and Update

When updating attributes of a contact, contact list, customer or customer list, Customer Connect UI provides the solution to keep track of the information of updated facts as a comment to be attached to the Customer Maintenance issue. The Customer Maintenance issue will be created with a default reason code Update Contact (for contact updates) and Update Customer (for customer updates). The Customer Maintenance issue will have its status to be set with two options based on the SV PE parameter CustMaintIssue_AutoClose_R as a toggle flag:

If CustMaintIssue_AutoClose_R is set YES, the Customer Maintenance will be set to Closed.

If CustMaintIssue_AutoClose_R is set NO, the Customer Maintenance will be set to Open (allowing the user to change the reson code for the issue before manually closing the issue).

There are two configurations requiring to setup:

Customer Maintenance Issue Reason Code PE Class CustomerMaintReason (PE ID = 758), which is a PE local class. That means this PE Class CustomerMaintReason will not be linked to a SV CB Reference Type.

The following data in this PE class are provided as samples below with SV CM core release:

ID Reason 6 New Additional Contact 7 Remove Additional Contact 8 Replace Primary Contact 9 Create Contact 10 Create Customer 11 Update Contact 13 Update Customer 14 Hierarchy Move 15 New Query 17 Update Query 18 Delete Query 20 Create Customer List 21 Update Customer List 22 Delete Customer List 24 Delete Customer Invoice Format 25 Update Customer Invoice Format 26 Create Customer Invoice Format 27 Update Contact List 28 Insert Contact List 29 Balance Transfer 30 Allowance Transfer 31 Create Document 32 Delete Document 34 Update Service 35 Update Balance Expiry Date 39 Update Product

The project team will need to re-evaluate all those entries as shown above to determine any updates to those entries through SV PE Workbench tools (pe_config tool).

The steps to maintenance the class CustomerMaintReason:

Start up app pe_config.

Login to PE config of workbench.

Select PE config Class tool button as shown below.

When the PE Class list is shown, search CustomerMaintReason as shown below.

Click the Data tab of CustomerMaintReason as a sample below.

Then click PE unlock button (with yellow color of lock icon) as shown below to make the class in update mode with a red color rectangle box.

Update the entries row by row, once the entries are finalized, click the commit button (with green color of check icon) to save the updates.

Once the PE update are done, need to restart CC UI.

Update SV PE Parameter CustMaintIssue_AutoClose_R based on project decision to leave Customer Maintenance issue to be Closed or Open.

The steps to maintenance PE Parameter CustMaintIssue_AutoClose_R:

Start up app pe_config.

Login to PE config of workbench.

Select PE Parameter tool button as shown below.

When PE Parameter tool is shown, search CustMaintIssue_AutoClose_R as shown below.

Unlock the PE parameter CustMaintIssue_AutoClose_R, Click Lock icon (with yellow color) and Lock icon will become non-highlighted situation.

Change YES to NO (or from NO to YES).

Click check icon (with green color) to save the update.

Restart the CC UI.

5.14.2. Customer Maintenance Issue for Customer Attributes/Lists and Contact Lists

When updating attributes of a customer or associated list information for contacts and customers, the system provides the ability to capture the updated information as a comment attached to the Customer Maintenance issue.

The Customer Maintenance issue will be created with a status of Closed by default. The issue will be assigned a Reason Code as shown below:

If Customer Attributes/Lists are updated the reason code will be set to Update Customer.

If Contact Lists are updated the reason code will be set to Update Contact.

The format of the generated comment is derived within the function perestapi.imp.fMaintIssueComment&, which can be modified as required. The default implementation of this function will capture the entity display name of the attribute or list being updated, as well as the old/previous value and the new/updated value. If new list data is being added, the new values will be captured. For list delete operations, the old list index values will be captured.

In order to support backward compatibility for existing CM implementations, an option within the api.PEREST.fConstants& function has been supplied. The constant MAINT_ISSUE_ENABLE& within this function will provide the following operation (where the default value is 1):

1 : Enable the creation of Customer Maintenance Issues and capture the updates to customer attributes and customer/contact lists comments at the API layer.

0 : Disable the tracking of updates within the Customer Maintenance Issue comments at the API layer and fall back to the default CM implementation of Customer Maintenance Issue.

5.14.2.1. Capturing Updates for Additional Lists

During a project implementation, new customer or contact lists may be added to the system. In the general case, new lists added to the system will be automatically handled by using the Entity Validation definition of the customer/contact list. Specifically, this means that the Attribute Type “Display Label” will be used to indicate which field was updated (which, depending on the JSON configuration for the UI may or may not be different to what is visible on the UI). It is expected that the project implementation will align the UI and attribute type captions to be the same.

There are some special cases for particular (special) customer lists:

For the Saved Payment Method customer list, the field display names captured in the comment are derived from the mapping table paymtd.dCustomerPaymentMethodSchemaType.

For fact-based customer list updates, the field display names captured in the comment are derived from the Entity Validation Attribute Label within the function perestapi.imp.fAuditCustDAList?[] (which can be modified if required). An example for one such scenario would be updating the Treatment Exemption of a customer.

For table data not defined by a Derived Attribute (the Invoice Format table for example), the list display name is explicitly passed.

5.14.3. Contact Email Verification

Projects to implement the logic of email verification in trigger: contactComms_Commit. In case of a delay in the response of email verification from the external system the verified flag will be set to FALSE else will be TRUE if the Encompass receives a response as verified from an external system.

5.14.4. Configuring File size for Document Upload

The uploadFileSize configuration is utilised to set the maximum file size for document uploads available across the entire application. This setting allows file sizes to be specified in either kilobytes (KB) or megabytes (MB), with options such as 20 MB or 20 KB. In instances where the configuration is incorrect or unavailable, the application defaults to a maximum file size of 20 MB.

5.14.5. PE Cache Guide for Document Upload

In case the Encompass document upload functionality is being used and documents are being uploaded to the Encompass database, the PE Private Cache may need to be increased to support uploading files greater than 5 MB.

5.14.6. PE Parameter Configuration

Name Display Name Expression Parameter Type Fact Type Reference Class Description order_PendgPayStatusEnabled order_PendgPayStatusEnabled False Expression Boolean None The project team must update the following parameter expression, to True in order to update the order status based on the payment status update. To enable or disable the order pending payment status updates.

5.15. Service Status Change Reason Configuration

In order to store the Service Status Change Reason against services (either primary or secondary services) while updating the service status, service types need to be configured accordingly. This gets realised through the service type entity validation (EV), where the EV will be configured to hold the status change reason.

For a service, the status change reason value gets stored in any of the available GENERAL_X fields, configured in the service type EV columns as a string based attribute type (AT). Currently the AT label is kept as a constant string Service Status Change Reason from the wls_ind.ServStatusChangeReason AT coming from wireless industry code pack (wls-ind.11.0.2).

The list of service status change reasons is taken from the PE class - ReasonForMaint, which in turn is fetching the reasons from the reference type (RT) perestapi.imp.UI_ORDER_REASON_CODE.

The projects are free to update the AT label as per their requirements, and update the same in the api.PEREST.fConstants& function against the constant SERVICE_STATUS_CHANGE_REASON$.

5.16. Geographic Address Management Configuration

Search and fetch for serviceable addresses (while doing serviceability check) is supported with a standard set of address fields, that has been provided in the released solution. To extend the address fields further (based on the address formats), projects can update the 'API To CB Field Mapping' derived attribute DA table as per their requirement (against the entity: GeographicAddress).

Address fields' values may be maintained within Encompass via reference types (RT) or outside Encompass as well (database tables or third-party address management system).

In order to fetch the data from the RTs, the 'Reference Type Name' and 'Reference Data Entity Name' columns should be configured in the 'API To CB Field Mapping' DA table with the respective RT abbreviation.

In case coming from non-RT sources, projects can refer to function api.imp.fPERestListGeographicAddressExecuteOperations& and perestapi.imp.fGetNextField?[] and configure the address field and fetching logic accordingly.

Validation of address is supported with a standard set of address fields, that has been provided in the released solution.

To extend the address fields further (based on the address formats), projects can update the 'API To CB Field Mapping' DA table as per their requirement (against the entity: GeographicAddressValidation).

Similar to above, address fields' values may be maintained within Encompass via reference types (RT) or outside Encompass as well (database tables or third-party address management system).

To fetch the data from the RTs, the 'Reference Type Name' and 'Reference Data Entity Name' columns should be configured in the 'API To CB Field Mapping' DA table with the respective RT abbreviation.

In case coming from non-RT sources, projects can refer to function api.imp.fPERestListGeographicAddressValidationExecuteOperations& and perestapi.imp.fCheckField& and configure the address field and fetching logic accordingly.

Note The released solution supports address fields via perest.others module address RTs. MMS solution, also provides alternate address support as well via accl.addr module.

6. Customer Configuration

6.1. Configuring Payment Methods

Customer Connect offers the flexibility to customise the payment methods presented in the Payment Screen. Application allows to configure multiple payment methods, security access for each payment method, sequence to display, unique set of fields for each of those payment methods etc.

Tip An implementation function (perestapi.imp.fSupportedPaymentFlowsDetails?{}) has been introduced to restrict payment methods based on Customer Connect payment flows. For more information, see the Installation and Integration Guide - PE REST APIs, specifically in the section Payment Management under Function configuration .

6.1.1. Configuring Payment Methods DA Tables

Payment Method Details DA along with paymtd.dCustomerPaymentMethodSchemaType DA allows to configure these use cases.

Configuration of Payment Method Details DA:

Table Column Column Description Payment Method (Index) Captures payment methods to be displayed in the payments section of the UI. Configurator can select from a set of values configured in RT perestapi.PAYMENT_METHOD_TYPE . Payment Type Maps the Payment Method to the corresponding Encompass Payment Type Entity. Menu Role Defines the Menu Role to control the accessibility of the Payment Method via User Security Profile. For a user to create Payments using this Payment Method, their security profile must have “write” access to the defined MENU_ITEM Reference Type option. For more information, see Configuring Payment Method Security Access . Stored Available? Defines whether a Payment Method of this type can be saved against a customer or not. Saved Payment Method for a customer are accessible in the Billing under Settings Tab of a Customer and will be available to use in Payment Screen (assuming the User has security access to that method). Always on Checkout? Defines whether this Payment Method will be available (with blank details) when taking a payment. If set to Yes , CSR can provide the necessary details for this Payment Method in Payment Screen. Note If Stored Available? column is set to No , this column is expected to be Yes . If both columns are No , the Payment Method cannot be stored against a customer or presented on the payment screen. Sequence Nr Configure to display the sequence in which Payment Methods are displayed. Note Payment Methods with Always on Checkout? set as Yes takes precedence over Payment Methods with Stored Available? as Yes. Payment Method Amount Validation Expression This is a comma-separated list of simple programming construct expressions, (similar to JavaScript). Each expression must evaluate to a boolean value (true or false). These expressions are used to validate the details of the payment method. Each expression acts as a rule that the payment method details must satisfy. For more information, see Payment Method Validation Expression . Validation Failure Message This field contains a pipe (|) separated list of translation keys. These keys correspond to specific error messages that will be displayed if any of the payment method validation expressions fail. Each validation expression has a corresponding failure message. When a validation expression fails, the application will display the error message associated with the translation key. The corresponding translations of translation keys can be provided in GLOSSARY under PAYMENT_METHOD_DETAILS_MESSAGES. IsMultipleInstancesAllowed? This setting determines whether a particular payment method can be used multiple times during the checkout process. For Example: Users can add multiple credit cards during the checkout process, allowing them to split the total payment across several cards. Success Message Format This defines the translation key whose translation will be displayed after a payment method is considered for payment, i.e., after successful validation on the checkout review screen and checkout success screen. Dynamic Parameters : The characteristics retrieved in the details of the payment method via the GET Payment API can be used as dynamic parameters in the translation message. The payment method name can be referenced as {paymentMethod} within the message. The above snapshot suggests that cardNumber and nameOnCard can be used as dynamic parameter in the translation message of Credit Card payment method. Translation Keys : The corresponding translations of these translation keys should be provided in the GLOSSARY under: PAYMENT_METHOD_DETAILS_MESSAGES. For Example: If the value of this field is configured as CREDIT_CARD_SUCCESS_MESSAGE then its corresponding translation can be provided in GLOSSARY under PAYMENT_METHOD_DETAILS_MESSAGES as follows: CREDIT_CARD_SUCCESS_MESSAGE: '{paymentMethod}: **** **** {cardNumber}', LOYALTY_POINT_SUCCESS_MESSAGE: 'Points: {totalAmountValue} LP'

paymtd.dCustomerPaymentMethodSchemaType DA defines the fields and their attributes associated with each Payment Method.

Configuration of paymtd.dCustomerPaymentMethodSchemaTypeDA Table:

Table Column Column Description Payment Method Type Specifies the Payment Method Type for which this field needs to be configured. Field Number Specifies the order of the fields. This helps in keeping fields in a specific order. Field Name The value will be used to map the value in the payload for post or patch requests. Field Display Name Specifies the label of the field. It is corresponding translation can be provided in GLOSSARY under PAYMENT_METHOD_DEFINITION_FIELDS. Mandatory Specifies whether the field is required to be filled to save a payment method or to use the new payment method in checkout. All Mandatory fields must be filled to enter the amount in the Payment method in checkout. Component Type Specifies the component to be displayed in the application. Tip The "String" component type can be used to configure a read-only component whose value can be derived from initialValueJsonPath as configured in direct-variables.config.json by setting the data source as “DV”. Visibility This setting determines when a field will be visible based on the context of saving or using a payment method. The following options are available: Always : The field will be visible both while saving a payment method and during payment. It will be editable when entering a new blank payment method at checkout but will be non-editable (read-only) for a saved payment method. Only while saving : The field will be visible only during the process of saving a payment method. It will not be visible during the payment process. Only while Paying : The field will be visible only during the payment process. It will be editable for both saved payment methods and new blank payment methods at checkout. Note For saved payment methods on the checkout page, the "Always" option means that the field will be visible but read-only. Data Source and Data Source Type Combination of Data Source Type and Data Source is used to determine from where data will be loaded in the components which require value selections. like drop-down and radio buttons. The following Data Source Types are supported: AT: Attribute Types as supported by referenceData API. RT: Reference Types as supported by referenceData API. DA: Derived Attributes Table data as supported by referenceData API. DB: CM Class_Fact as supported by referenceData API. CM: CM class as supported by referenceData API. DV: Direct variables as defined in direct-variables.config.json . This can be used to populate dynamic drop-down options and to assign an initial value of the fields. For more information, see Introducing Direct Variables . Tip The direct variables data source can be used to derive dependent dropdowns, allowing control of subsequent selections. For example, selecting a country populates the states drop-down with states of the selected country, and selecting a state populates the cities drop-down with cities of the selected state. All form fields configured as field names of a payment method, along with the payment method amount referenced as {{amount}}, can be used as query parameters in the requestUrl of apiAttributes as defined in direct-variables.config.json. For more information, see Achieving Control Next: Managing Dependent Dropdowns .

Note Payment Method Details DA to be configured for all the required Payment Methods. For example: Cash Payment Method is delivered by default with no field level configuration in paymtd.dCustomerPaymentMethodSchemaType DA , but has an entry for Payment Method Details DA. This ensures that CSR can process Cash as a Payment without accepting any fields. Configuration for Cash, Credit Card, Loyalty Points, and Others Payment under the Payment Method Details DA is delivered as reference data, which are the default Payment Methods for the Customer Connect application. Additional sample configuration for paymtd.PaymentMethod Payment Type, like tokenizedCard, bankCard, etc., are delivered with the PERESTAPI code pack.

Payment Type Function Mapping:

The DA table contains mapping for customisable functions to each payment type and API operations. Attribute derivation function field derives various attributes (facts) values before the main API commits the Payment to DB, where as optional Post processing function field is called after commit to finalise payment creation or modification. This DA should be updated if a new payment type is created by implementation teams.

Following are some sample default values provided along with code pack:

6.1.1.1. Payment Method Validation Expression

Validation Expression

This is a comma-separated list of simple programming construct expressions, similar to JavaScript. Each expression must evaluate to a boolean value (true or false). These expressions are used to validate the details of the payment method.

Each expression acts as a rule that the payment method details must satisfy.

The validation expressions are evaluated after entering the amount.

An expression is evaluated only after all the fields used in the expression have a value. This implies that the mandatory validation should still be governed by the "mandatory" column in the payment method schema type DA table.

All the form fields configured as field names in the payment method schema type DA table can be used as variables in the expression. Additionally, the following variables are available for use in an expression.

Variable Name Description amount The payment method amount as input by the user. immediateAmount The total amount payable in context. prepaidBalanceConsumed The prepaid balance consumed amount as input by the user.

Tip All these variables can also be used as dynamic parameters in the translation message.

Validation Failure Message

This field contains a pipe (|) separated list of translation keys. These keys correspond to specific error messages that will be displayed if any of the payment method validation expressions fail.

Each validation expression must have a corresponding failure message defined in the same sequence as the expressions. When a validation expression fails, the application will display the error message associated with the translation key.

The corresponding translations of translation keys can be provided in GLOSSARY under PAYMENT_METHOD_DETAILS_MESSAGES.

If the translation key is not found, the actual message configured here will be shown.

Payment Method Details Configuration:

Payment Method Payment Method Amount Validation Expression Validation Failure Message Credit Card String(cardNumber).length == 4,String(cvv).length == 3 CARD_NO_INVALID_MSG| CVV_NO_INVALID_MSG Cash amount==immediateAmount CASH_SPLIT_NOT_ALLOWED

Glossary Translation File Configuration:

PAYMENT_METHOD_DETAILS_MESSAGE { CARD_NO_INVALID_MSG: 'Please enter only the last 4 digits of your card number.', CVV_NO_INVALID_MSG: The CVV ({cvv}) number entered is invalid. CVV number should be 3 digits long.', CASH_SPLIT_NOT_ALLOWED_MSG: 'Cash payment cannot be split.', }

Credit Card Payment Method:

Validation Expressions:

String(cardNumber).length == 4: This checks that the cardNumber field must contain exactly 4 characters.

String(cvv).length == 3: This checks that the CVV field must contain exactly 3 characters.

Validation Failure Messages:

If cardNumber is not 4 characters long, the application will display the message associated with CARD_NO_INVALID_MSG: "Please enter only the last 4 digits of your card number".

If CVV is not 3 characters long, the application will display the message associated with CVV_NO_INVALID_MSG: "The CVV ({cvv}) number entered is invalid. CVV number should be 3 digits long".

Cash Payment Method:

Validation Expression:

amount == immediateAmount: This checks that the amount must be equal to the immediateAmount (total amount payable in context).

Validation Failure Message:

If the amount is not equal to immediateAmount, the application will display the message associated with CASH_SPLIT_NOT_ALLOWED_MSG: "Cash payment cannot be split".

Application Interpretation:

When a user selects the Credit Card payment method:

If they enter a card number that is not exactly 4 digits long, the application will show the message "Please enter only the last 4 digits of your card number".

If they enter a CVV number that is not exactly 3 digits long, the application will show the message "The CVV ({cvv}) number entered is invalid. CVV number should be 3 digits long". Here, {cvv} will be replaced with the actual CVV number entered by the user.

When a user selects the Cash payment method:

If the entered amount does not equal the immediateAmount, the application will show the message "Cash payment cannot be split".

Note The values entered by the user for the fields used in validation expressions must adhere to a specific pattern for security reasons. Only alpha-numeric values are allowed, and a period (.) can only be used as a decimal separator between digits. If the entered values do not meet this pattern, an implicit pattern validation message will be displayed.

6.1.2. Configuring Payment Method Security Access

The list of Payment Methods available to process by a CSR taking a payment within the Customer Connect application can be configured based on security access. The payment method tabs are associated with access levels of menu roles and can be defined per security profile.

The following diagram shows the default payment methods on the payment form that can be configured:

BA Transfer and BA Debit are the Saved Payment Methods with Save icon.

The following MENU_ITEM Reference Codes have been included in the perestapi code pack, and are mapped by default to the available payment method tabs within the UI:

The MENU_ITEM configuration is the same as other areas of the application, specifically:

If the Security Profile does not reference the MENU_ITEM code, no access is allowed.

Access Level: 0 (View access) – the payment method details can be viewed but cannot be used to create a payment.

Access Level: 1 (Update access) – the payment method can be updated and used to create a payment.

Note Preferred payment method tab is only displayed if the customer has a Stored Payment Method as per the customer Billing under Settings tab.

6.1.3. Configuring Others Payment Method

Payment Types fetched on the Payments tab of the billing screens are fetched using reference data Payment_Type PE class.

For generic payment types (dynamically added ones), add them in Payment Method Generic RT along with their specific RTs in the column Child List for supporting further payment-specific values.

To configure payment methods:

Log in to Business & Administration Studio.

Click Lists from the Reference Data menu.

Search the Payment Method Generic reference type.

Open the Payment Method Generic reference type.

Click the Edit icon to edit the reference type.

Click the + icon to insert a new row. Code ID is auto-assigned if a new row is added to the reference type

Enter the Code Label.

Enter the Display Label.

Enter the description.

Enable the payment method.

Select the Child List from the drop-down list depending on the requirement.

Select the Child Attribute Type from the drop-down list depending on the requirement.

Click the Tick Mark icon to save the changes.

Note The Fields of Others method cannot be configured using paymtd.dCustomerPaymentMethodSchemaTypeDA . However, it can be hidden by removing the row from Payment Method Details DA or setting the value of the Always on Checkout? Flag to No .

6.1.4. Configuring Payment Type Filter

Payments made using different payment modes can be retrieved using the Payment Type filter.

To configure payment filters:

Log in to Business & Administration Studio.

Open the Payment Types Filter Definition DA table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Payment Type drop-down list, select the payment type.

In the Subtype Field drop-down list, select the subtype field.

Enter the Subtype Field Name.

In the Reference Type drop-down list, select the reference type.

The payment type filter displayed in the Customer Connect.

To get the default value from classes data in reference data api:

Name CCIsDefault_B Class Payment_Type Display Name IsDefault Description Default payment type indicator. Type Boolean Stored Yes Derivation None Initial State Optional Fact Usage None Reference Class None Length None Table Column None Derivation Expression None

Fact - Payment_Type class

Payment_Type class fact can be utilised for different classes to define the default value in the reference data.

Note Set the CCIsDefault_B value to True only for the respective row of that class.

6.1.5. Overriding Stored Payment Methods

In order to provide more flexibility in using Stored Payment Methods for different project scenarios (such as using payment methods stored at a parent node), the function perestapi.imp.fDerivePayMethodCustomerId& can be used and this function has two parameters CBInputData?{} and customerId. The second parameter, the customerId can be overridden and the return value of the function can be ignored. The payment will still be made to the requested target customer account; however, the stored payment method list will be retrieved from the overridden customer node.

This function will have the current Customer Node ID passed as a parameter, as well as the current Case reference within the CBInputData? {} hash structure parameter.

For example:

CBInputData? {'CASE_ID’}.

6.2. Configuring Customer Status Change Reason

Customer status change reason drop-down in the Customer Connect are configured using the customer status change reason DA table.

To configure the status change reason drop-down:

Search the Customer status change reason table.

Open the Customer status change reason table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the From Status and To Status drop-down list, select the status.

In the Sequence Nr field enter number as configurator want reasons to be displayed in the drop-down.

In the Status Change Reason drop-down list, select the reason.

Note Status change reason’s value can be configured as per requirements. Project can add or remove any value through RT-accl.cust.STATUS_CHANGE_REASON .

Select the Default as Yes to default the reason.

Click the Tick Mark icon to save the changes.

6.3. Configuring Global Search Filters

The main search bar is to find Customers, Contacts, Cases, and Orders using different parameters in Customer Connect.

Global search filters in Customer Connect are configured using the Global Search Filters reference type. There are four reference types that can be configured:

Cases: RT perestapi.imp.case.GlobalSrchFilters

Contacts: RT perestapi.imp.contact.GlobalSrchFilters

Customers: RT perestapi.imp.cust.GlobalSrchFilters

Orders: RT perestapi.imp.order.GlobalSrchFilters

To configure the global search filters:

Open the Global Search Filters reference type.

Click the Edit icon to edit the table.

Click the '+'' icon to insert a new row to the table.

Enter the Code ID, Code Label, Display Label, and Enabled?.

For example, data configured for Orders global search filters.

In Customer Connect, when Orders is selected, the global search filters for orders will be displayed.

6.4. Configuring Account

6.4.1. Account Actions

Account Actions are the operations that are allowed to be performed on an account. DA Account Status Operations maps Account Actions/Operations for a unique combination of Account Type and Account Status.

The Derived Attribute (DA) should be populated by projects to support Account Actions as per the requirement. The DA should contain entries for all permitted Actions. If an account does not have a corresponding entry, the system will fetch the Account Actions from the DA with a ‘Default’ status. If no entry with a ‘Default’ status is found in the DA table, then the default options, which are configured in the NGUI constants file, will be displayed on the screen.

Note Account Actions available for a user depends on the user’s security profile.

These are the Actions, defaulted in Customer Connect:

List for Postpaid:

Make Payment

Create Adjustment

Create Dispute

Transfer Balance

One of charges

Generate Immediate Bill(report level = Invoice) or Generate Statement(report level != Invoice)

List for Prepaid:

Recharge

Create Adjustment

Transfer Balance

Extend Balance Expiry

Generate Statement

List for Deposit:

Generate Statement

To configure the Account Status Operations DA table:

Log in to Business & Administration Studio.

Click Tables from the Reference Data menu.

Search the Account Status Operations.

Open the Account Status Operations.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Account Type Name drop-down list, select the account type.

In the Account Status drop-down list, select the status.

Enter the Sequence Nr.

In the Account operations drop-down list, select the account operation compatible with the account type.

Click the Tick Mark icon to save the changes.

Note To cancel editing or stop adding a new row to the DA table, click the Cancel Edit icon.

6.4.2. Account Classification

Customer Connect supports Prepaid, Postpaid, and Deposit classification of Account types.

DA Account Classification maps each account type in the system to the respective supported classification.

DA is to be populated by projects to support the classification and display of accounts on the billing screen.

If the project has additional account types in use, they will all be classified as Others on the billing screen.

To configure the Account Classification DA table:

Log in to Business & Administration Studio.

Click Tables from the Reference Data menu.

Search the Account Classification.

Open the Account Classification.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Account Type Name drop-down list, select the account type.

In the Classified As drop-down list, select the classification compatible with the account type that is being used in the project.

Click the Tick Mark icon to save the changes.

6.4.3. Balance Transfer

An eligible customer (Sender) is entitled to transfer the balance amount from their account to another eligible customer (Receiver) prepaid account. The Sender is required to have an active account and an active subscription that is configured with the Balance Transfer feature as part of an offer sold to the customer. An eligible Receiver should have at least one active prepaid account and an active subscription.

The target balance Receiver can be searched using multiple options such as Customer Name, Account Name, MSISDN, etc. The account used by default to transfer balance will be the first Prepaid Account under the Receiver.

Similarly, the Sender and Receiver MSISDN used during Balance Transfer for notifications and comments under the Issue, will be the latest Active Service Name. In Case of Sender, it will be the latest Active Subscription having the Balance Transfer Feature configured.

The default prepaid account retrieved while searching for the Receiver can be overridden with custom logic within the function perestapi.imp.fDeriveReceiverAccountDetails&. During the Balance Transfer, the derivation logic for the MSISDN used for notifications to Sender and Receiver can be altered as required within the functions perestapi.imp.fDeriveSenderMSISDN& and perestapi.imp.fDeriveReceiverMSISDN& respectively.

The eligibility criteria required for Balance Transfer will not be altered by modifying the above functions.

Note While searching for the Receiver account, the Account Number displayed in results is by default the Primary Account Number, even though the Active Prepaid Account is used to do Balance Transfer. For example, while searching for the Receiver (Hybrid Customer), the Postpaid Account Number will be displayed even though the Prepaid Account will be used to transfer the balance. MSISDN used to search for Receiver may not always be the one which receives notification or the one mentioned under the Issue Comments. The MSISDN of Receiver notified or displayed in the Comments would be the value derived in perestapi.imp.fDeriveReceiverMSISDN& . Additional configuration (such as the minimum/maximum transfer amount, total transfer amounts in last 24 hours/30 days, transaction fees, etc. can be configured as per the Reference Design for Balance Transfer Module of Product Pricing code pack document).

6.4.4. Aged Debt Classification

Account Types provide the ability to classify the amount owed to the Service Provider broken down into buckets defined by date range offsets. Customer Connect allows a user to view the amount owed by the customer for each defined bucket as per this configuration.

For example:

Postpaid Account Type is configured for testing to have aging classification as below:

Sample aging classification entry:

Note that the Classification Expression is maintained by the system when updating the classification attributes.

In order to support backward compatibility, an option within the api.PEREST.fConstants& function has been supplied. The constant AGED_DEBT_ENABLE& within this function can be used to enable/disable the Aged Debt information being passed through APIs (Default option is to enable – value being one).

Note For more information on aged debt classification, refer to Account Types under the Financial Guide for Singleview.

6.5. Configuring Order Reason Codes

Support is available to extend the list of reason codes captured during an order. This section will outline the steps needed to add more reason codes for CSR selection during order processing.

Each order to change an existing subscription requires a reason for the change. This allows the service provider to analyse the trends of order changes to understand why their subscribers are requesting changes.

The system supports displaying different sets of reason codes for different order operations based on the offer category; for example, a different set of reason codes can be displayed for adding a deposit offer versus adding a VAS offer versus removing a VAS offer.

6.5.1. Reason for Maintenance Codes

Changing an existing subscription requires capturing a reason for the change. The reason codes available depend on the “Offer Category” (specifically, the category of offer as per the UI display or the service level menu selection such as Changing Plan) and the “Order Operation” (which are the operations supported by the UI which include values such as “Add”, “Remove”, “Suspend”, and “Reactivate”).

The values within the Offer Category and Order Operation are maintained by the UI and are not editable by implementation teams.

The list of reason codes available for these offer categories and operations is maintained in the reference type 'perestapi.UI_ORDER_REASON_CODE':

The reason codes for selection by a CSR are defined by configuring the reason code against the desired offer category and operation within the Derived Attribute table “UI Order Reason Codes” as per below:

Note that for a given combination of UI Order Category and Operation, the set of reason codes displayed to the CSR is ordered by the Sequence Number.

Also, if a particular reason code is more likely than the rest, one of the codes can be assigned to be the “Default” which will be automatically pre-selected when the list of reason codes is presented. If there is only one Reason Code configured within the set, and if the Reason Code is marked as “Default”, then the selection of a Reason Code by the CSR is automatically performed, and the reason code capture screen may be skipped.

6.5.1.1. Complex Orders and Default Values

Some orders require multiple operations within the same request, such as adding offers from different categories, or changing the status of multiple child offers. In such cases, the UI may not be able to determine a single category or operation and will look up the “UI Order Reason Codes” table using the indexes of “Default” and “Default” to present a generic list of Reason Codes.

Also, if no configuration changes are made to add specific reason codes for a particular Order Category or Operation combination, the system will present the “Default” set of reason codes for selection.

The “Default” set of reason codes can be configured, but there must always be a set of “Default” reason codes defined.

6.5.1.2. Sample Reason Code Configuration

For the Modify Offer flow (alter product order), UI Order Category to be set as Modify Offer and Operation to be set as Default.

6.5.2. Reason for Cancellation Codes

When changing an existing subscription, a reason for the change must be provided. In addition, when performing a cancellation or removal of an offer, a “Cancellation Reason” must be supplied. Depending on the change, this reason code may be used to determine additional logic the system needs to execute. For example, the system could potentially be configured to waive a contract cancellation fee if a contract offer is terminated due to the death of the subscriber.

It should be noted that some operations may require a “Cancellation Reason” in case the operation requires removing offers, such as the Change Plan operation (which may need to remove incompatible offers as part of the change).

The reason codes available depend on the “Offer Category” (specifically, the category of offer as per the UI display, or the service level menu selection such as Changing Plan or terminating the service) and the “Order Operation” (which are the operations supported by the UI, which typically would be “Remove”).

The values within the Offer Category and Order Operation are maintained by the UI and are not editable by implementation teams.

The list of reason codes available for these offer categories and operations is maintained in the reference type 'prodprice.cmn.CANCEL_REASON':

The reason codes for selection by a CSR are defined by configuring the reason code against the desired offer category and operation within the Derived Attribute table “UI Order Cancellation Reason Codes” as per below:

Note that for a given combination of UI Order Category and Operation, the set of reason codes displayed to the CSR is ordered by the Sequence Number.

Also, if a particular reason code is more likely than the rest, one of the codes can be assigned to be the “Default” which will be automatically pre-selected when the list of reason codes is presented. If there is only one Reason Code configured within the set, and if the Reason Code is marked as “Default”, then the selection of a Reason Code by the CSR is automatically performed, and the reason code capture screen may be skipped.

6.5.2.1. Complex Orders and Default Values

Some orders require multiple operations within the same request, such as cancelling multiple offers from different categories. In such cases, the UI may not be able to determine a single category or operation and will look up the “UI Order Cancellation Reason Codes” table using the indexes of “Default” and “Default” to present a generic list of Reason Codes.

Also, if no configuration changes are made to add specific reason codes for a particular Order Category or Operation combination, the system will present the “Default” set of reason codes for selection.

The “Default” set of reason codes can be configured, but there must always be a set of “Default” reason codes defined.

6.5.3. Removing Reason Codes

It should be noted that Reason Codes (both for Maintenance and Cancellation) are not supported if those reason codes have previously been used in order processing. Existing orders will reference these values, and retrieving such orders will fail unless the reason code exists.

If a Reason Code is to be retired from use, updating the relevant Reference Code (within the Reference Type) to set the “Enabled?” flag to “False” will prevent it from appearing for selection (but will allow the system to display it on existing orders).

6.5.4. Reason to Advance Collection Process to another Treatment Steps

When CSR advance collection process to another treatment steps, a reason must be provided.

The list of reason codes available for Edit treatment step is maintained in the reference type treatment.imp.STEP_SKIP_REASON:

6.5.5. Reason for Equipment Swap

Swapping existing equipment requires capturing a reason for the change. The available reason codes depend on the UI Order Category (MSISDN Swap and SIM Swap) and the Operation (which is Default in the case of Equipment Swap).

Rows with above mentioned combination needs to be present in the DA table UI Order Reason Codes as shown below:

The Default set of reason codes can be configured, but it must always be defined.

6.5.6. Updating the Payment Arrangement Instalment Due Date or Instalment Amount

When CSR updates the payment arrangement instalment due date or instalment amount, a reason is required.

The list of reason codes available for Edit payment arrangement installment due date or instalment amount is maintained in the reference type treatment.imp.INSTALMENT_REASON.

6.6. Capture Consent Configuration

Customer’s consent is required to collect their details (phone number, email and preference) and to use their data (for marketing or customising the service based on their preferences) to serve them better.

CSR must be able to capture consent during contact creation for applicable contact types. The consent information can be viewed and updated based on CSR privileges.

Customer Connect Application will have screens to capture, display and modify (with appropriate CSR privileges) customer’s consent for various privacy-related questions.

For more information on CSR privileges, see Security Framework.

LIST ConsentQuestionDefinition API is used to fetch the consent questions associated with the person type.

LIST/PATCH entityDerivedAttribute APIs are used to capture, display and modify consent questions for a person type.

These APIs are implemented based on the CB API code pack framework.

JSON specification is used as the standard for input and output structure.

The data mapping between internal and external fields is maintained through a DA table (api.dAPIToCBFieldMapping).

Project teams can use the existing PersonConsentList DA or can create new DA for Consent questions.

Attribute types used in DA should be based on the reference type. If not, project team should update LIST ConsentQuestionDefinition API to handle other data types of attribute type as per the project requirements.

Reference type used in attribute types of DA should have the default value set for NGUI to display the default response of consent question on consent form.

To display question in read-only section, configure only one response and default it as well.

Each question must have one default response.

Function:

api.PEREST.fConstants& The constant PERSON_TYPE_CONSENT_DA?{} must be updated by mapping person type and DA that contains consent questions so that its details will be fetched by LIST ConsentQuestionDefinition API.

const PERSON_TYPE_CONSENT_DA?{} := hash(['accl.cust.Residential', 'PersonConsentList', 'accl.cust.Business', 'PersonConsentList']);

Enable and Configure Capture Consent Feature

Parameter Configuration Description isCaptureConsentEnabled: true To enable Capture Consent, the static.config.json (path - ./assets/config/static.config.json) must be configured.

To Support configurable headings for the screen. Change the value in the below file.

Path -./assets/i18n/customer-contact/en.json

Note The default values seen on the screen as No is coming from API, and project teams need to configure that.

6.7. Adjustment Type Reason Mapping Configuration

Adjustment Type Reason Mapping DA configured to map the Adjustment Type and Reason. Customer Connect UI will use this information in Adjustment Screen.

Search the Adjustment Type Reason Mapping table.

Open the Adjustment Type Reason Mapping table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Adjustment Type drop-down list, select the adjustment type.

In Sequence Nr, enter the incremental sequence number.

In the Reason drop-down list, select the associated reason.

In the Default drop-down list, select the default value.

Click the Tick Mark icon to save the changes.

Note Adjustment type, Sequence Nr, Reason and Default all are mandatory. Set the Default Field value to Yes to make that reason the default value for the Adjustment type.

6.8. Managing Disputes

6.8.1. Configuring Dispute Resolve Definition

Dispute Resolve Definition DA is configured to map the Dispute Status, Resolution and Adjustment Type.

Customer Connect UI will use this information to resolve the dispute.

Search the Dispute Resolve Definition table table.

Open the Dispute Resolve Definition table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Status drop-down list, select the status.

From the Resolution drop-down list, select the resolution.

In the Adjustment Type drop-down list, select the adjustment type.

Click the Tick Mark icon to save the changes.

Note Status and Resolution are mandatory while Adjustment Type is optional. And also configure Status and Resolution mapping in derived attribute daCM_DisputeResolutionStatus as it is configured in above DA.

6.8.2. Invoice Language

The Reference Type INVXML.INVOICE_LANGUAGE is introduced to store the list of invoice languages used for a particular invoice or statement.

The Attribute Type invxml.InvoiceLanguage is attached to General 3 of Entity Validation invxml.cif.FormatDetails.

At present we do not support the translation of invoice to the invoice languages included in this RT. The implementation for language support to be extended by projects.

6.8.3. Invoice Address Choice

The Reference Type INVXML.EMAIL_ADDRESS_CHOICE is introduced to store the list of email address choices to use for a particular invoice or statement.

The Attribute Type invxml.AddressChoice is attached to General 4 of Entity Validation invxml.cif.FormatDetails which is a union of values defined in reference type ADDRESS_CHOICE and INVXML.EMAIL_ADDRESS_CHOICE.

Note While adding an invoice format, when user select’s email as delivery method but choses a non-email address choice from ADDRESS_CHOICE ReferenceType, an error will be thrown.

6.8.4. Resend Invoice Link

The Reference Type perestapi.imp.NOTIFICATION_METHOD is introduced to store a list of notification methods to resend invoice link.

Additionally, these reference data are attached with child reference Types/list. perestapi.imp.SMS_ADDRESS_CHOICE, perestapi.imp.EMAIL_ADDRESS_CHOICE. This child reference type contains notification address choice to resend bill notifications and are introduced for Customer Connect to configure a drop-down selection based on notification method and notificationAddressChoice.

The logic to send invoice link is only set for the email notification method with the primary contact’s email address. The implementation for resending bill notifications via other notification channel support to be extended by projects.

Note Email is set as default value for reference type perestapi.imp.NOTIFICATION_METHOD and Primary Contact Email Address as default value for child reference type perestapi.imp.EMAIL_ADDRESS_CHOICE.

6.9. Dispute Adjustment Reason Mapping Configuration

The Dispute Adjustment Reason Mapping DA is configured to map the Adjustment Type and Dispute Reason to the Adjustment Reason. The dispute acceptance process will use this information to determine the Adjustment Reason to use for the generated adjustment record.

Search the Dispute Adjustment Reason Mapping table.

Open the Dispute Adjustment Reason Mapping table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Adjustment Type drop-down list, select the adjustment type.

In the Dispute Reason drop-down list, select the dispute reason.

In the Adjustment Reason drop-down list, select the adjustment reason to use.

Click the Tick Mark icon to save the changes.

Note There should be a row for each Adjustment Type/Dispute Reason combination that is used by the dispute issue workflow. A missing entry will cause the dispute acceptance process to fail when it tries to update the adjustment record.

6.10. External Applications: Contextual URL Invocation for Customer, Case, and Contact Management

The application allows opening of customer, contact or case based on the invoked URL from the external application. The source of information for the application is the URL query parameters. Based on the URL parameters, the application will identify and establish the context.

6.10.1. Structure of the URL

The URL follows the format.

{{Protocol}}://{{ApplicationNetworkAddress}}/web/redirect?utility={{UtilityName}}&key={{SearchKeyName}}&value={{SearchValue}}

{{Protocol}}: This part indicates the protocol used to access the resource, which can be either http or https, depending on server configuration.

{{ApplicationNetworkAddress}}: It represents the combination of the hostname or machine name and the port.

{{UtilityName}}: This is the name of the utility that specifies the type of entity the application should retrieve or search for.

{{SearchKeyName}} and {{SearchValue}}: These parameters are used to identify and establish context within the application. They are used for searching specific entities.

6.10.1.1. Configuring Optional Parameters

The configuration of the optional parameters for the redirect utility URL:

Parameter Use Cases Source The URL follows the format: {{Protocol}}://{{ApplicationNetworkAddress}}/web/redirect?utility={{UtilityName}}&key={{SearchKeyName}}&value={{SearchValue}}&source={{sourceValue}} An example URL is provided as follows: http://sinlxsves21:50140/web/redirect?utility=searchContact&key=name&value=Will%20Smith&source=Email {{sourceValue}} The source value is referenced from CM Class ‘How_Received’, and it will be used as the value of the source for the newly created Case. Note This optional parameter is only supported in the searchCustomer and searchContact utilities, and a warning will be presented if used with the searchCase utility. If the source value is not passed in the URL, then it will be taken from the configuration key-value pair of sourceName in the static.config.json file. If no configuration is done, then the source value defaults to ‘CC-Incoming Phone’.

6.10.2. Example for URL

An example URL is provided as follows:

http://sinlxsves21:50140/web/redirect?utility=searchCustomer&key=MSISDN&value=92900268

In this example, the protocol is http, the application network address is sinlxsves21:50140, the utility name is searchCustomer, and the search key name is MSISDN with a corresponding search value of 92900268.

6.10.3. Functionality Overview: Supported Utilities and Search Keys

The following three utilities are supported by the application. The possible values of the search keys are retrieved from the respective reference types, which vary according to the utility used.

Utility Name Description searchCustomer This utility is employed to search for a customer based on the provided key and its corresponding value. If this utility is invoked, a new case will be created. The possible values of the search key are retrieved from perestapi.imp.cust.GlobalSrchFilters RT. Additionally, 'customer id' is also supported. Example URL: http://sinlxsves21:50140/web/redirect?utility=searchCustomer&key=MSISDN&value=92900268 In this example, the application searches for a customer with the MSISDN 92900268 . If a unique customer record is found, the application redirects to the customer overview screen for the retrieved customer. searchContact This utility is utilised to search for a contact based on the specified key and its associated value. Similar to the searchCustomer utility, invoking this utility also results in the creation of a new case. The possible values of the search key are retrieved from perestapi.imp.contact.GlobalSrchFilters RT. Additionally, contact id is also supported. Example URL: http://sinlxsves21:50140/web/redirect?utility=searchContact&key=National%20Id&value=1212121289 In this example, the application searches for a contact with the National ID 1212121289 . If a unique contact record is found, the application redirects to the contact overview screen for the retrieved contact. searchCase This utility is designed for searching cases based on the specified key and its corresponding value. The behavior of this utility differs based on the related parties associated with the case: If the case has only a contact as the related party, the application redirects to the contact overview. If the case has both a contact and a customer as related parties, the application redirects to the customer overview. The possible values of the search key are retrieved from perestapi.imp.case.GlobalSrchFilters RT. ExampleURL: http://sinlxsves21:50140/web/redirect?utility=searchCase&key=Case%20Id&value=C197968 In this example, the application searches for a case with the ID C197968 . If a unique case record is found, the application redirects to the customer overview screen associated with the case, and the details of case C197968 are displayed in the case panel.

6.10.4. Redirecting Behaviors: Rules and Configuring Preferences

The redirection will be seamless if SSO is used. However, if SSO is not used, the application will be redirected to the login screen. After the user enters the Username and Password, the application will be redirected to the respective screen of the utility used.

The redirection of the application is impacted based on the number of records retrieved.

Number of Record(s) Redirection Rule One The application will be redirected to the respective screen of the utility used. Greater than one The application will be redirected to the global search screen. All the retrieved records will be presented on the screen for the user to select the appropriate record. Zero The application will be redirected to the global search screen with an auto-selected search key and prefilled search value. The user can then refine the search.

Following static configuration can be used for managing advanced redirection behavior.

Redirect Utilities Static Configuration

All settings for redirect utilities will be placed under the "redirectUtilities" object in the static configuration. Each utility will have its own key named after the utility, with its own settings relevant to the utility.

Search Customer and Search Contact Configuration

Search Customer and Search Contact utilities are configured based on the search key, where each flow based on the key is configured independently. The utility’s config has a “key" object, clearly indicating that all its properties are for flows for a given key, and then inside there are settings for each key.

Global structure of "redirectUtilities" object:

"redirectUtilities": { "searchCustomer": {…}, "searchContact": {…} }

Possible parameters:

Parameter Configuration Description “mandatoryValidation” Only applicable if the search query has one exact match. The user will land on global search page with that one match and a prospect panel opened for the user to complete validation. Does not apply in case the key is "customer id"(Search Customer Utility) or "contact id" (Search Contact Utility). “draftIssueType” If provided it will be preset and the draft issue form will be opened after creating the case and landing on Customer Overview or Contact Info page. Only applicable if key/value has one exact match which will automatically trigger loading of customer or contact. In case of a search returning multiple matches, the user will just be redirected to a search page. “draftIsMandatory” If draftIssueType is provided, can change whether the draft issue form is mandatory. If draftIssueType is not provided, this will be ignored. This property is optional, and if omitted default will be used.

Examples of Search Customer and Search Contact configuration:

Example Description "redirectUtilities": { "searchCustomer": { "key": { "msisdn": { "mandatoryValidation": true, "draftIssueType": "Troubleshooting", "draftIsMandatory": true } } } } When searching using the "msisdn" key in this example of the Search Customer utility: validation will be enforced “draftIssueType” and “draftIsMandatory” are set. "redirectUtilities": { "searchContact: { "key": { "email id": { "mandatoryValidation": true, "draftIssueType": "Troubleshooting", "draftIsMandatory": true } } } } When searching using the " email id" key in this example of the Search Contact utility: validation will be enforced “draftIssueType” and “draftIsMandatory” are set.

6.10.5. Redirection Workflow from CTI Application: Conceptual Diagram

6.10.6. Redirection Workflow from CTI Application: Sequence Diagram

6.11. Anatomy for Summary of Change Comment Model

The comments of type "Summary of Change" adhere to a specific structure and shall be added to the order to display on the UI. The actual comment property is JSON stringified object. This object contains all the data to show in Summary table on Order page after it’s JSON parsed back from saved comment. Additional rows can be added to the summary table in the order detail page.

Comments must adhere to following structure (example):

{ "origin": "client", "showInUI": true, "changesDataSource": [ { "offerName": { "main": "Vaccine Mobile Postpaid Mega Plan (CX/UX).", "subScript": "89232788" }, "planName": { "main": "Vaccine Mobile Postpaid Mega Plan (CX/UX).", "subScript": "89232788" }, "activity": { "main": "Change Plan", "subScript": "" }, "changes": [ { "title": "", "initialValue": "Vaccine Mobile Postpaid Mega Plan (CX/UX).", "finalValue": "Postpaid Plan 2" } ] } ] }

The comment has two main properties:

origin: Typically “client” which indicates that the comment itself is coming from the UI - saved during POST or PATCH of the order. Origin: "client" shall not be added as it is considered as a unique identifier for client originated comments. There must be only one Summary of Change comment with origin: "client" where all additional changes (rows in UI table) can be appended to changesDataSource array (explained below).

showInUI: Determines if the changes are to be shown in the UI table on the Order page. The showInUI attribute must be added for the UI to consider it for the display.

changesDataSource: This is the list of actual changes where each element in the array corresponds to a row in the table.

changesDataSource objects:

offerName: The name of the offer that has been changed. Optionally, in the subscript, it can have extra data (typically service name, if that offer has it).

planName: The name of the plan or the parent’s name in general. If the changed offer is part of Logical TLO in a bundle, then the Logical TLO name will be used here. Otherwise, it will always be Root TLO name. Optionally, in the subscript, it can have extra data (typically service name).

activity: A short explanation of the nature of the change. Optionally it can have subscript for more details, for example, price name for negotiations.

changes: List of actual changes. There can be more than one change being recorded, for example, multiple attributes changed at once. If more than change, then only the first will be shown, followed by how many more (“+1 more”) and info icon. Upon hovering over the icon the popup will a full list of changes will be shown.

There are three parameters here, each being optional, to utilize here, depending on how you want to present the data. Typically, initialValue and finalValue will be used to show the before/after state with an arrow in between. Alternatively, only title can be used to show just text. Or all three combined in cases like price changes where we want to show before/after price but also prefix it with currency used.

6.12. Configuring Notifications for History and Alerts

AlertSummary String:

To obtain a list of alerts, the alert API is called. This populates a list of alerts in the Customer Overview, Service Dashboard, and the Customer History screen. In the alert list, configurator receives the alert summary along with other alert values. This alert summary will be in the format specified below in some cases:

EmailAddress ⇒ [A1.iamgroot@csgi.com, AA1.iamgroot@csgi.com] | Subject ⇒ Order Completion Notification | EmailContent⇒ <html><head><META http-equiv="Content-Type" content="text/html;charset=utf-8"><title></title></head><body>Dear Customer,<br /><br />Your free units entitlements/allocated package is expiring or expired.<br /> <br />Configurator can purchase additional Service using Mobily App. http://mobily.im/App<br /><br />Thank you for choosing Mobily.<br /> </body></html>

Supported Keywords Description | Pipe symbol is used as a field delimiter. It should not be used to separate key value pairs as it would be converted to a new line space. Example: Emailaddress ⇒ [ A1.iamgroot@csgi.com , AA1.iamgroot@csgi.com ] | Subject ⇒ Order Completion Notification Will be converted to Emailaddress: A1.iamgroot@csgi.com , AA1.iamgroot@csgi.com Subject: Order Completion Notification [ A1.iamgroot@csgi.com , AA1.iamgroot@csgi.com ] If there are multiple values, keep them in an array format. ⇒ Is used as a key value delimiter. This should not be used inside a string; this will be converted to a “:” and the value before it will be used as a key and after it will be used as a value. Example: Subject ⇒ Order Completion Notification Will be converted to Subject: Order Completion Notification <br> Break line tag is also supported to move to a new line in the HTML content. <b> - Bold text <strong> - Important text <i> - Italic text <em> - Emphasized text <mark> - Marked text <small> - Smaller text <ins> - Inserted text <sub> - Subscript text <sup> - Superscript text These HTML text formatting tags are supported. &nbsp; It is supported to add a tab space in HTML.

Parameter Configuration Description enableAlertSummaryFiltering Use this parameter to configure the filtering of the alert summary data that is coming from the alert API. If it is set to true, the application parses the received data’s HTML tags. If it is set to false, will disable this parsing.

6.13. Customer and Contact Association Roles

Configure the Association Role Mapping DA to enable the necessary contact role mapping with respect to customer type. If the DA is populated, the system by default will assign the role to the primary contact created based on the customer type. There will not be a contact role pop-up when making the secondary to primary contact, and the list of roles displayed will be based on the customer type fetched from the DA using the Reference Data API.

Configured DA is shown below:

6.14. Essential Payment Consideration for Order Completion

Keys and Descriptions:

useExternalAdviceOfCharge: This flag enables or disables the use of an external "Advice of Charge" system. If set to true, the system will use an external "Advice of Charge" service to calculate immediate payments. Otherwise, it will use the internal system for payment calculations.

useExternalNegotiatedAdviceOfCharge: This flag enables or disables the use of an external "Negotiated Advice of Charge" system. If set to true, the system will use an external "Negotiated Advice of Charge" service. Otherwise, it will use the internal system for negotiated payment calculations and if override are performed on Advice of Charge price then that price must have product instance ID present.

AdviceOfChargePriceTypeColumnAssignment: This configuration is used to distribute various price types to their respective columns in the "Advice of Charge" table. If a price type is not explicitly configured under any column, it will appear in the "Other" column.

includeUpfrontAmountInAOC: Set to 'true' to include the upfront amount, calculated based on the offer price specifications, in the payload of the 'adviceOfCharge' API.

Columns:

Upfront: Contains price types for upfront payments and discounts.

Deposit: Contains price types for deposits.

Recurring: Contains price types for recurring payments, real-time periodic payments, and installments.

Configuration for various flows:

Property Description offerPriceTypes List of price types from offer price specifications eligible for immediate payment for sales order. Excludes Cancellation, RealTimeCancellation, and InstallmentPenalty price types. Discounts will be deducted from their associated parent price types. adviceOfChargePriceTypes List of "Advice of Charge" price types eligible for immediate payment for sales order. enableAdviceOfCharge Boolean flag to determine whether the "Advice of Charge" or "Quote API" should be called for the sales order flow.

Note The offerPriceTypes and adviceOfChargePriceTypes must specify the exact price type. Example: To select only the Recurring price type for immediate payment, then specify ["Recurring"]. To select only the RealtimePeriodic price type for immediate payment, then specify ["RealtimePeriodic"]. To select both the Recurring and RealtimePeriodic price types for immediate payment, then specify ["Recurring", "RealtimePeriodic"].

Property Description salesOrder Configuration for the Sales Order flow. Note The offer price types will be considered for all products in the sales order. modifyOffer Configuration for the Modify Offer flow. Note The price specifications will only be considered for added products during offer modification. addChildOffer Configuration for the Add Child Offer flow, which involves adding child offers or services. Note This configuration applies to both the "Add Child Offer" and "Add Service" flows in the application. The price specifications will only be considered for the added products. The "Replace Offer" and "Replace Device" flows will use the configuration of "Add Child Offer". changePlan Configuration for the Change Plan flow, which involves changing subscription plans. Note The offerPriceTypes configured here will be negated for carried-over price specifications, as they were previously collected during the purchase of the product. The remaining amount that should be collected for carried-over price specifications should be returned from the "Advice of Charge" API as a positive value, and the amount that should be refunded should be returned as a negative charge from the "Advice of Charge" API. removeChildOffer Configuration for the Remove Child Offer flow, which involves removing child-level offers or services. Note This configuration applies to both the removal of a child-level offer and the removal of a service (logical TLO). The offer price types are not applicable for this flow. Only "Advice of Charge" price types will be considered for immediate payment. simChange Configuration for the SIM Change flow. Note The offer price types are not applicable for this flow. Only "Advice of Charge" price types will be considered for immediate payment. msisdnChange Configuration for the MSISDN Change flow. Note The offer price types are not applicable for this flow. Only "Advice of Charge" price types will be considered for immediate payment.

6.15. Steps to Configure Issue Types

To configure the Issue Types, the High Level Design (HLD) flowchart:

Note Core Reason Issue Type is used as a sample for configuration purpose.

Step-2A: Define Section Layout for new Issue Type

Define a list of section fields required for a new custom Issue Type or 'Troubleshooting' Core Issue Type, into IssueTypeSectionDisplay DA.

Define the Section Display Name and Section Sequence Number for the defined section in the DA.

Define if the section mapped to Issue Type needs to be hidden or displayed for the entries when made to IssueTypeDefinitionSchema DA.

The Troubleshooting issue-type core sections will be released with the release package and are not recommended for removal.

To remove sections that are mapped already, do not remove the rows from the table but update the Section Hidden (Y/N) column provided for the purpose.

Step-2B: Define Issue Layout for new Issue Type

Define a list of fields required for a new custom Issue Type and add them into IssueTypeDefinitionSchema DA.

Required row is inserted as a sample: 'coreReason' as a sample custom Issue Type or 'Troubleshooting' as a core Issue Type under the DA table.

Step-2C: (Optional) Issue Type Security Group Setup

If user access control is required for specific issue type(s) for it is (their) new issue object(s) creation and update, project is able to define the security group(s) and specific issue type(s) one-to-one mapping in DA table perestapi.dIssTypeSecGroupMap shown below. If the issue objects are already existing prior to this security group DA entry setup. They are not impacted and are accessible as original, usually fully accessible.

By default, the issue types are not defined in the following DA table are fully accessible for creation.

Assign the above security group(s) and the access levels to the user profile(s) that are granted access to the issue type(s) creation

User User Profile IssueType Security Group Issue Type Access Description for Issue Type Access Level Issue Object Issue Object Access Description for Issue Object Access Level SV Configuration Sample CSR1 CSR_GROUP1 Core Reason CM_IMP_IssueType_SG1 RO User can only VIEW Core Reason Issue Type Core Reason267931 R/U Users can Read Core Reason267931 MGR1 REGION_MGR Core Reason CM_IMP_IssueType_SG1 RW Users can CREATE/UPDATE Core Reason Issue Type Core Reason267931 C/R/U Users can Create/Read/Update Core Reason267931 CSR2 CSR_GROUP2 Core Reason CM_IMP_IssueType_SG1 NA User has no access to Core Reason Issue Type Core Reason267931 R/U Users can Read/Update Core Reason267931 OPR1 OPR_GROUP Core Reason CM_IMP_IssueType_SG1 NA User has no access to Core Reason Issue Type Core Reason267931 NA User has no access to Core Reason267931

Step-2D: (Optional) Setup Issue Type & Action Type Compatibility

Capable to define a few Action Types are not eligible to a given Issue Type. The Issue Types and their incompatible Action Types are defined in DA table perestapi.dIssActTypeCompat.

By default, the Issue types and Action Types are not defined in the following DA table are fully compatible.

Step-3: Issue Class Update

If the field defined in the IssueTypeDefinition DA table are not supported by the existing facts of the Issue Class, update the Issue Class to define new fact.

For the creation part refer to step-4 and sub-steps.

Step-4: Functionality to support new IssueType

Step-4A: Define new Issue Type

Create a new Issue Types or choose existing issue type(s) not displayed on the CC UI Case panel.A new Issue Type will be added into Issue_Type class from Encompass 'PE Config' workbench.

'Core Reason' sample Issue Type is being inserted in the Class.

Once sample Issue Type being added, it is necessary to purge the class once.

Note If the created sample Issue Type does not reflect, the workaround is to purge the PE cache if the new entry is not immediately presented in the configuration in the next step.

Purge Command: PE command to purge the class. Command: 'pe_admin -pc <key>' where 'key' is the unique identification of the class under 'Detail' tab.

Example: Purged the class under required environment and ran the command:

Issue_Type Class → Detail Tab → Unique Identifier 'Key' value.

Step-4B: Create Issue Type Reason Code Class and DA

For the sample Issue Type, Core Reason Class, a new fact called UI_CustomReason_R is created under the Issue class to store the customReasonCode.

Purge the Issue class once the Fact is created. Command: 'pe_admin -pc <key>' where 'key' is the unique identification of the class under 'Detail' Tab.

For sample Issue Type and Core Reason, the customreasonCode needed to be multilevel drop-down.

Based on this, a new Reason Code CoreReason_IssueType_Sample class and required facts; Details, Inquiry_Class and Inquiry_Type created.

This is the structured static class categorised with three levels of facts.

CoreReason_IssueType_Sample Class → Detail Tab:

CoreReason_IssueType_Sample → Data Tab:

Note Name Needs to be unique Identified for each row inserted in the Data tab. Sample Data Inserted accordingly in the Details, Inquiry_Class and Inquiry_Type facts respectively.

Below are the required facts created for CoreReason_IssueType_Sample class.

Inquiry_Class Fact:

Inquiry_Type Fact:

Detail Fact:

Purge the CoreReason_IssueType_Sample class, once the class and its facts are created. Command: 'pe_admin -pc <key>' where 'key' is the unique identification of the class under Detail tab.

The newly created Reason Code Class Name CoreReason_IssueType_Sample class needs to be mapped against it’s Issue Type Core Reason in Issue Type Reason Mapping DA.

Example: Under row 18: Core Reason Issue Type is mapped to CoreReason_IssueType_Sample Reason Code class name.

Step 4C: Configure Issue Type Section Display DA and Issue Type Definition Schema Type DA

Configuration : Issue Type Section DA

Issue Type Section Display:

Each issue type form should be organised into sections, grouping related fields together. These sections are associated with specific issue types as outlined in the table below. New sections can be added to the perestapi.SECTION_NAME reference type.

Column Title Column Description Issue Type Identifies the issue type to which the section is mapped. Section Name The unique identifier of the section. Section Display Name Specifies the label of the section. It is corresponding translation can be provided under GLOSSARY under ISSUE_TYPE_SECTION_DISPLAY. Section Sequence Number Specifies the order of the section display in the application. Section Hidden (Y/N) Specifier whether the section should be hidden or not in the application.

Tip The order in which the issue types will be presented can be controlled through static configuration parameter issueCreationSequenceList , for more information, see Static Parameter Configuration .

Configuration : Issue Type Definition Schema Type DA

Issue Type Definition Schema Type:

This table contains the definition of issue type form fields mapped to their respective sections.

Column Title Column Description Issue Type Specifies the issue type in which this field should be added. Section Name Specifies the section which will contain this field. Field Sequence Number Specifies the order of the field in the mapped section. Field Name Specifies the unique identifier of the field. The field name can be configured with or without a pipe operator. When using the pipe operator, the left-hand side of the '|' operator represents the form field name and the right-hand side of the '|' operator represents the payload key. If the field name is configured without the pipe operator, the value serves as both the form field name and the payload key. If a payload key is specified, it will be used as the characteristic name within the issueItem object in the POST Issue and PATCH Issue API payloads. If no payload key is provided, the form field name will be used instead. The same will be used to map the saved values back to the field from GET Issue API response. Note This is also used while defining field dependencies in “Issue Type Field Dependency DA” as well as the dynamic query parameters in request URL in direct-variables.config.json to support dependent drop-downs. Field Display Name Specifies the label of the field. Its corresponding translation can be provided under GLOSSARY under ISSUE_TYPE_DEFINITION_FIELDS Mandatory Specifies whether the field is required to create or update an issue. Editable This controls the disability of the field. It supports four options: Yes: This suggests that the field will always be enabled. No: This suggests that the field will always be disabled. Create Mode Only: This suggests that the field will only be enabled during issue creation. Update Mode Only: This suggests that the field will only be enabled during issue update. Visible This controls the visibility of the field. It also supports four options: Yes: This suggests that the field will always be visible. No: This suggests that the field never be visible. Create Mode Only: This suggests that the field will only be visible during issue creation. Update Mode Only: This suggests that the field will only be visible during issue update. Display Component and Display Component SubType The combination of Display Component and Display Component SubType specifies the component that should be displayed in the application. For more information on supported types, see Controlling the Field Display . Data Source and Data Source Type The Combination of Data Source and Data Source Type is used to determine from where data will be loaded in the components which require value selections. Like drop-down, radio buttons and checkbox. Following Data Source Types are supported: AT: Attribute Types as supported by referenceData API. RT: Reference Types as supported by referenceData API. DA: Derived Attributes Table data as supported by referenceData API. DB: CM Class_Fact as supported by referenceData API. CM: CM class as supported by referenceData API. DV: Direct variables as defined in direct-variables.config.json. This can be used to populate dynamic drop-down options, to assign an initial value of the fields and supporting the dependent dropdowns. For more information, see Introducing Direct Variables . Aspect Ratio Specifies width of the field. The total width of row is divided into 12 units. For each field the minimum value is two and maximum value is 12. For example: If 3 fields of equal width are required in a row then the aspect ratio of the each of the field should be 4. Once the sum of fields in sequence exceeds 12, the application will automatically span the subsequent fields to the new row.

Note Reason Code : To activate Reason Code functionality in the framework, need a combination of values respectively. Display Component SubType : Multi level drop-down Data Source Type : DA Data Source : perestapi.dIssueTypeReasonMapping

Controlling the Field Display:

The combination of Display Component and Display Component SubType specifies the component that should be displayed in the application.

Following table lists down the supported combinations:

Display Component Type Description Display Component SubType Checkbox Represented by a small square that can be either checked (selected) or unchecked (deselected). The value “True” will be passed in the payload if it is checked. Conversely, “False” will be passed in the payload if it is unchecked. None. Date Consists of an input field where the date is displayed and a pop-up calendar from which the user can choose a date. None. Document Integrated component for managing documents. Note The documents are uploaded using Upload Document API by passing the created issue ID post issue creation. Only one Document component is supported per issue type form. None. IncidentList Integrated component for managing incidents. The selected incidentId will be sent in the payload and additional characteristic newIncidentRequest with value True or False depending on whether request for new incident is made. Note Only one IncidentList component is supported per issue type form. None. Radio Button Allows to select one option from a predefined set of options. When a radio button is selected, it displays a filled circle, providing visual feedback to the user. None. Dropdown Consists of a closed display area (the dropdown) and an arrow or indicator that, when clicked or hovered over, reveals a list of options to choose from. Auto Complete Dropdown: A component that provides suggestions as the user types into an input field. It dynamically suggests options that match the user’s input, typically based on a predefined list. Multi level Dropdown: extends the functionality of a standard dropdown menu by allowing nested levels of options within each dropdown menu item. This hierarchical structure enables users to navigate through multiple levels of related options or categories, typically organised in a tree-like structure. Text Fundamental element to capture textual input from the users. String: It allows users to enter and edit alphanumeric characters, including letters, numbers, and symbols, without any specific formatting or restrictions String(ReadOnly): It is particularly useful when the information that should not be editable by the user needs to be displayed such as display-only data or pre-filled information that users can view but not alter. Number: It restricts input to numeric values, including integers and floating-point numbers. Email: It enforces basic validation rules to ensure that the entered text follows the standard format of an email address. TextArea: A text area allows for longer, multi-line input, making it suitable for capturing paragraphs, comments, descriptions, or any other sizable textual content. Password: It is used to capture sensitive textual input from users, such as passwords or PINs. It differs from standard text boxes in that it hides the characters typed by the user, typically displaying asterisks or dots instead of the actual characters, to protect the confidentiality of the input. Amount: It captures monetary values from users while displaying a specified currency format, adhering to the customer’s preferred currency if set; otherwise, defaulting to the customer’s primary account currency. It ensures that the currency symbol remains visible and consistent while users enter the numerical value and validate that only valid numeric inputs are accepted based on the currency.

Configuration : Issue Type Field Dependency DA

(Optional) - This step is essential for introducing field dependencies, meaning making other fields or sections hidden, disabled, or mandatory based on specific values selected in the parent field. The rules configured in this DA will override the default mandatory, visible and editable configuration of the fields in all the modes.

Issue Type Field Dependency:

Column Title Column Description Issue Type The issue type for which the dependency should be created. Parent Field The field whose selection or value should influence the attributes of other fields. The fields which are configured for the selected issue type in the Issue Type Definition Schema Type DA table will be available for selection. Section Name The dependent section which should be influenced by the selection or input of specific values in parent field. The sections which are configured for the selected issue type in the Issue Type Section Display DA will be available for selection. Dependent Field The dependent field which should be influenced by the selection or input of specific values in parent field. The fields which are configured for the selected issue type and the selected dependent section in the Issue Type Definition Schema Type DA table will be available for selection. Note This is an optional column. If it is left empty then the dependency will be applicable on the entire dependent section. Dependency Rule Type The attribute of the dependent field or section that should be influenced. Possible values are; Mandatory, Disabled, and Hidden. Note By default all the fields are considered enabled and visible. The default value of mandatory attribute is defined in Issue Type Definition Schema Type DA. If the user changes the selection in the parent field, and the configured trigger values are no longer satisfied, the affected attributes or behaviors of other fields revert to their default state. Dependency Rule Value The attribute value of the dependent field or section, Possible values are; Yes and No. Note In the event of conflicting rules, attributes designated with a value of 'Yes' will take precedence. Dependency Rule Trigger The specific values of the parent field which should influence the configured attribute of dependent section or the dependent field. Pipe(|) is used as the separator to define multiple individual values. The values defined can be combination of multiple static values and multiple reference data. The reference data specified must have one of AT, RT, CM, DB, DA as the prefix depending on the reference data type followed by '-' and the name of reference data. For Example: AT-invxml.InvoiceDelivery, RT-CREDIT_RATING, CM-Time_Type, DA-accl.addr.dMapCountryState-India, DB-Issue_Status, Along with the static values there are two reserved keywords supported i.e. EMPTY and NOT_EMPTY. The terms EMPTY and NOT_EMPTY serve as reserved keywords to trigger dependency rule based on the presence or absence of a value in a particular field. Here are their definitions: EMPTY : This keyword typically refers to a field that does not have any value entered or selected. In forms, a field is considered "EMPTY" if no input or selection has been made by the user. For example, if a drop-down menu or a text field or a checkbox or a document control or a date field is left blank, it would be considered "empty". NOT_EMPTY : Conversely, NOT_EMPTY refers to a field that has a value entered, selected. If any input or selection is made in the field, it is considered "NOT_EMPTY". This includes any form of user input such as text, selection from a drop-down, checkbox selection, radio button selection, document upload etc.

Configuration Illustration and Overview

Issue Type Parent Field Dependent Section Dependent Field Dependency Rule Type Dependency Rule Value Dependency Rule Trigger Core Reason country Location of Problem What3Words Mandatory Yes RT-MandatoryCountryGeoCode|Vatican City|Monaco Core Reason reasonCode Hardware Section None Hidden Yes EMPTY|RT-NetworkReason1|RT-NetworkReason2 Core Reason reasonCode Network Section None Hidden Yes EMPTY|RT-HardwareReason1|RT-HardwareReason2 Core Reason state Income Tax Documents document Mandatory Yes DA-accl.addr.dMapCountryState-India|DA-accl.addr.dMapCountryState-Barbados Core Reason priority1 Communication Priority priority2 Mandatory Yes Email|Facebook

Application’s Interpretation of above configured rules:

The first rule suggests making What3Words field mandatory if the country selected is any of the values from reference type RT-MandatoryCountryGeoCode or Vatican City or Monaco.

If “RT-MandatoryCountryGeoCode” has “India, UAE, Australia, Barbados, Canada, and Brazil” as ref codes then the application will make What3Words as mandatory if the CSR selects any of India, UAE, Australia, Barbados, Canada, Brazil, Vatican City, and Monaco.

The second rule suggests hiding “Hardware section” if the reason code selected is empty or any of the values from “RT-NetworkReason1” and “RT-NetworkReason2”.

If “RT-NetworkReason1” has “DNSERR, TIMEOUT, UNREACHABLE, FWBLOCK” and “RT-NetworkReason2” has “BWLIMIT, AUTHERR, SSLERR, CONGESTION” as refcodes then the Hardware section will be hidden if CSR selects any of “DNSERR, TIMEOUT, UNREACHABLE, FWBLOCK, BWLIMIT, AUTHERR, SSLERR, CONGESTION”.

The third rule suggests hiding Network Section if the reason code selected is empty or any of the values from “RT-HardwareReason1 and RT-HardwareReason2”.

If “RT-HardwareReason1” has “HWFAILURE, OVERHEAT, POWERLOSS, FANFAILURE, DISKERROR” and “RT-HardwareReason2” has “MEMORYERR, CPUERR, IOERROR, BUSERR, NICFAILURE, USBFAILURE, SCREENERR” as refcodes then the “Network Section” will be hidden if CSR selects any of “HWFAILURE, OVERHEAT, POWERLOSS, FANFAILURE, DISKERROR, MEMORYERR, CPUERR, IOERROR, BUSERR, NICFAILURE, USBFAILURE, SCREENERR”.

The fourth rule suggests requiring the document field if any Indian or Barbadian state is selected.

For more context, refdata API supports querying DA tables as well with index columns, so DA-accl.addr.dMapCountryState is having mapping of countries and state with country as index column. DA-accl.addr.dMapCountryState-India will return Indian states and DA-accl.addr.dMapCountryState-Barbados returns Barbadian states.

So, document field will be mandatory if CSR selects any of “Christ Church, St Andrew, Bangalore Rural, Bangalore Urban, Delhi, Karnataka or Chennai”.

The fifth rule suggests making priority2 mandatory if CSR selects any of Email or Facebook in priority1.

API_CB Mapping

Update API_CB Field Mapping DA to support newly added Custom Issue Type.

For sample Issue Type Core Reason and the field added customReasonCode, for the same API To CB Field Mapping is being updated Issue Type Entity Name and PERestPost as Action, row four and five is inserted below.

For sample Issue Type Core Reason and the field added customReasonCode, for the same API To CB Field Mapping is being updated with Issue Type as Entity Name and PERestGetResponse as Action and row is inserted below.

Step-4D: New Issue Type API Functions

GET APIs are required to fetch new Issue Type definition defined in DA.

perestapi.sample.issue.get.fDeriveCoreReasonDetails& and for POST: perestapi.sample.issue.post.fDeriveCoreReasonDetails& under required environment.

Sample GET & POST Core Reason Details Functions:

Step-4E: Issue Type Function Mapping DA

Configure the following functions to create or update issue objects of the new Issue Type.

Issue Type Function Mapping For Issue Type - Core Reason:

Uncomment the below lines of code of 'api.imp.fPERestListIssueReasonExecuteOperations&' function.

api.imp.fPERestListIssueReasonExecuteOperations Function:

Step-5: Option To Install Sample Issue Type From Delipack

As a sample new Issue Type setup demo, also sample Core Reason Issue Type can be installed from Delipack optionally.

6.15.1. Account Adjustment Issue Type Configuration Guidelines

The configuration for the account adjustment issue type is established using this framework. Certain fundamental configurations are provided, which are crucial for the immediate functionality of the system. Care should be exercised when modifying these default configurations to prevent unintended consequences.

The following are some general configuration guidelines.

The pairing of the data source type "DA" and the data source "perestapi.imp.dAccStatusOperations" guarantees the listing of billing accounts that support the "CREATE ADJUSTMENT" operation as configured in perestapi.imp.dAccStatusOperations DA table for adjustmentToAccount field.

The combination of the data source type "DV" and the data source "directVariables.user.operatorAdjLimit" ensures that the CSR Adjustment Limit is populated as configured in the direct-variables.config.json file.

Note It is crucial to note that if a customer’s preferred currency is specified, it must be configured in the Currency class. If not specified, the customer’s primary account currency should be configured in the Currency class. If neither is configured, the adjustment limit will be left blank. The adjustment limit, initially defined in the adjustment currency, is converted to all currencies as defined in the Currency class. The application then selects the adjustment limit in the customer’s preferred currency (if specified) or in the customer’s primary account currency.

There is a dependency rule defined between adjustmentAmount and adjustmentLimit fields in Issue Type Field Dependency DA table. If this dependency is removed, then the confirmation message for adjustment amount exceeding authorised adjustment limit will not be shown.

6.15.2. Deposit Transfer to Debtor Account Adjustment Type Configuration Guidelines

Issue Type Definition Schema Type DA

initialDepositAmount, remainingDepositAmount, adjustmentFromAccount, serviceName, productOfferName and productInstanceId are added as hidden fields to support the deposit transfer adjustment type. These settings should not be updated.

Issue Type Field Dependency DA

Overrides for initialDepositAmount, remainingDepositAmount, adjustmentFromAccount, serviceName and productInstanceId are provided to make them visible when adjustment type “Deposit Transfer to Debtor Account” is selected. These settings should not be updated.

productOfferName remains hidden and will not be sent by the client during issue creation. But this can be made visible and enabled in issue creation by setting an override to make it visible.

6.15.3. Troubleshooting Issue Type Configuration Guidelines

The configuration for the troubleshooting issue type is established using this framework. Certain fundamental configurations are provided, which are crucial for the immediate functionality of the system. Care should be exercised when modifying these default configurations to prevent unintended consequences. The following are some general configuration guidelines.

The pairing of the data source type "DA" and the data source" “perestapi.dIssueTypeReasonMapping" in IssueTypeSchemaDefn DA table guarantees the listing of reason codes in the multilevel dropdown configured.

There are certain dependencies provided in “Issue Type Field Dependeny DA table” which makes the configured fields mandatory. Care should be taken while trying to modify these dependencies.

6.15.4. One-off Charge Issue Type Configuration Guidelines

The configuration for the one-off charge issue type is established using this framework. Certain fundamental configurations are provided, which are crucial for the immediate functionality of the system. Care should be exercised when modifying these default configurations to prevent unintended consequences. The following are some general configuration guidelines:

The pairing of the data source type "DA" and the data source" “perestapi.dIssueTypeReasonMapping" in IssueTypeSchemaDefn DA table guarantees the listing of reason codes in the multilevel drop-down configured.

There are certain dependencies provided in “Issue Type Field Dependeny DA table” which makes the configured fields hidden or disabled. Care should be taken while trying to modify these dependencies.

The topLevelOffer field is configured to be always hidden and its visibility depends on the selected service number. When a service number is selected, the direct variable for topLevelOffer will set the values in it. The topLevelOffer field is necessary to trigger the adhocChargeRefData API, which retrieves the amount in the Charge Details section.

The accountLevelAmount and serviceLevelAmount fields are configured in the DA table to support different API calls for the amount field. Depending on the selected service number, the UI will display only one of these fields: serviceLevelAmount when a service number is selected, and accountLevelAmount if no service number is selected.

Additionally, the accountLevelOverrideEnabled and serviceLevelOverrideEnabled fields are configured in the DA table, which remains hidden. This configuration is necessary to manage the enabling or disabling of the two distinct amount fields effectively.

6.15.4.1. Managing Dynamic Amount Fields Based on Service Selection

Since direct variable keys must be unique, configuring two APIs for a single field directly is not possible. To address this limitation, use two distinct amount fields and manage their dynamic visibility. This approach allows for handling different API calls or the same API call with varying query parameters for the dynamically rendered fields.

In this use case, the accountLevelAmount and serviceLevelAmount fields are dynamically managed based on the service number selected by the user. Here is a detailed explanation of the configuration and its use:

Field Configuration: The accountLevelAmount and serviceLevelAmount fields are defined in the Issue Type Schema Definition DA table to cater to different API calls for the amount field. The field names are specified using a pipe (|) operator.

Field Name Component Type Data Source Type Data Source accountLevelAmount|adhocAmount Amount DV directVariables.accountAdhocCharge.accountLevelAmount serviceLevelAmount|adhocAmount Amount DV directVariables.serviceAdhocCharge.serviceLevelAmount

Each field is assigned a unique direct variable key, with corresponding API details defined in the direct-variables.config.json file.

Depending on whether a service number is selected or not, the UI will display only one of these fields based on the configuration made in Issue Type Field Dependency DA table:

When a service number is selected, the serviceLevelAmount field is shown.

If no service number is selected, the accountLevelAmount field is displayed.

Issue Type Parent Field Section Name Dependent Field Dependency Rule Type Dependency Rule Value Dependency Rule Trigger accountLevelAmount|adhocAmount adhocServiceName One-off Charge: Charge Details accountLevelAmount|adhocAmount Hidden Yes NOT_EMPTY serviceLevelAmount|adhocAmount adhocServiceName One-off Charge: Charge Details serviceLevelAmount|adhocAmount Hidden Yes EMPTY

6.16. Configuring Contract Document Upload During Orders

During the flow of Product Orders, the system allows the capture of documents representing legal contracts associated with each Contract Companion Feature. An action of type “Upload Contract Document” is created to track the same on Post or Patch ProductOrder API in case the order consists of at least one Contract Companion Feature with mandatory document configured. Triggering Patch Action API to complete the associated action will now validate if all the mandatory contract documents are captured, in the function perestapi.imp.action.patch.fUploadContractDocument&. Finally, in Submit API, the system validates if there are no open actions of type “Upload Contract Document” and associates the documents with the corresponding Companion Product Instances that are created.

In the case of Alter Ownership flow, the documents are associated with the Order ID and existing Product Instances, and for the rest of the flows the documents are associated with the Order Id & Offer Node Id’s. Once the Order is Accepted, the documents are mapped on to the New Product Instances in the same order.

The “Action Type Function Mapping” DA table has been configured for Upload Contract Document Action Type with the attribute derive function as perestapi.imp.action.patch.fUploadContractDocument&. Projects can update the function to introduce project specific logic, for example, if the documents are captured externally this validation can be skipped or altered as required while closing the action.

Two PE Parameters have been introduced to control the upload of contract document during the order flow:

Parameter Description order_uploadContractDoc_R This parameter is used to validate if the companion product requires a contract document to be uploaded during an order. If the expression resolves to ‘YES’, the function “perestapi.fUploadContract&” is called to validate if the companion product (from its Offer definition) requires a contract document to be uploaded. If the expression resolves to ‘NO’, no further checking is done for contract documents during an order. In the case of Alter Ownership order type (i.e. changing the owning customer node of a subscription), the new approach enforces the order Submit API to be called to complete the Product Order. This allows the application to trigger the creation of an Action (of the specified type) during the POST ProductOrder API and validate if the Action is completed in subsequent Submit API. The Action is to be updated to ‘Completed’ (or ‘Cancelled’) status by the implementation team once the document is successfully uploaded and then call the Submit API to complete the Product Order. act_UploadContract_R Determines the action type to create as part of an order that requires a contract document to be uploaded. The default Action Type used is “Upload Contract Document”. If an open action of this type exists when an order is being submitted, the order will fail with an error message informing the user that a contract document is required to be uploaded before the order can be submitted. The expectation is that the contract document upload process will close any outstanding document upload action so the order can progress.

Note By default, the expression in order_uploadContractDoc_R is set as ‘NO’. This can be changed to ‘YES’ based on implementation requirements. If these parameters are updated to enforce contract document uploads during an order, it is anticipated that the Customer Connect application be configured such that the UI allow contract documents to be uploaded. To do this, the “Order Entry Task Framework” needs to be enabled (using the static configuration parameter orderTaskFlow , see Configuring Order Task Framework ).

The following is an example of this table configuration where the key settings are the Order Stage of “Checkout” and Task of “Contract”.

Note The Catalog, Category, Order Type, Order Sub Type (and possibly Reason Code) need to align to implementation requirements.

6.17. Treatment Payment Arrangement Rule

To configure the Treatment Payment Arrangement Rule table in the Customer Connect application:

Search the Treatment Payment Arrangement Rule table.

Open the Treatment Payment Arrangement Rule table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Treatment Strategy drop-down list, select the Strategy or select *Any*.

In the Maximum Broken Limit, type the limit for maximum broken Payment Arrangements.

In the Update Instalment Amount Threshold (%), type the threshold limit for the edit instalment amount.

6.18. Configure Billing Settings Forms and Tables

Visibility on the various forms (boxed in orange) at Billing Settings can be configured via the Dynamic Form framework.

The dynamic-forms.config.json configuration file contains sections under “customerBillingSettings” which correspond to display racks on the Billing under Settings screen, for example, “Account Settings”. Each section under the rack corresponds to a form or table.

Whether the form will be shown or hidden is based on 2 factors.

Taking the configured Saved Payment Methods form as an example:

formTag

Form will be shown for Customer Types listed in the formTag list (boxed in blue above). The values refer to the Display Name of the customer type.

entityType/ genericTableConfigKey (boxed in green above)

This will be factored in only when entityType = "derivedAttribute".

The set of Customer Derived Attribute Lists available for this customer (i.e. Derived Attributes with a storage context of “Customer” or “Customer Node”, which are usually based on the Customer Type definition) will be returned within the GET entityDeriveAttribute API with Customer ID on the payload. The genericTableConfigKey as defined in the dynamic-forms.config.json file will be used to compare with the returned table Display Names and if a match is found, the form will be shown provided it also fulfills the customer type indicated in the formTag list above.

Note If entityType = "derivedAttribute", both factors must be fulfilled for the form to be shown. If entityType <> "derivedAttribute", only formTag factor needs to be fulfilled for the form to be shown. If All forms under the rack is hidden, the heading of the rack (example: “Account Settings”, “Exemption Settings” etc.) will be hidden too.

6.19. Customising Customer or Contact Screens

Refer to the Configurability Framework guide for instructions on building project-specific screens.

7. Integration Infrastructure Configuration

7.1. API Error Model

API returns the full error message code with the prefix.

API hides optional empty fields.

API returns the cause in the reason attribute.

API adds a new action attribute and returns the action.

7.1.1. API Error Message

The HTTP 4xx or 5xx standard error codes must be used in the response header.

An API may supports user and the application-specific error codes.

The user and application-specific error codes must be represented in the error representation (body) of the response.

Subcodes are possible (400-2). However, they must be in the error representation (body).

Error representation in the body of the response must have the following structure:

Property Description Mandatory code Application-related code (as defined in the API or from a common list). Mandatory reason Text that explains the reason for the error. This can be displayed to a client user. Mandatory message Text that provides more details and corrective actions related to the error. This can be displayed to a client user. Optional action Corrective actions for the error that can be displayed to a client user. Optional status http error code extension like 400-2. Optional referenceError url pointing to documentation describing the error. Optional @type The class type of a REST resource. Optional @schemaLocation It provides a link to the schema describing a REST resource. Optional

Example:

400 Bad Request Content-type:application/json { "code": "ERR001", "reason": "Missing mandatory field", "message": "Please provide and Authorisation header" "action": "Enter a value into the field before moving to another record or another block.” }

The supported error codes must be defined in the API specification. @type and @schemaLocation must be used for the run time extension of the error.

7.1.2. API Warning Message

All warning messages from SV servers are returned as API error responses to the UI application. UI application presents the warning messages to CSR for further actions (for example: cancel or proceed). Should the CSR decide to proceed, the UI application will call the same API request again, together with ignored warning message IDs. The missed warning messages will then be bypassed in SV and the transaction will proceed to completion.

Below flowchart illustrates the "warning→warning→success" interactions among the interface components, where CC=Customer Connect, PEREST=Adapter, API=PERESTAPI and PE Server = f_rsp

Below flowchart illustrates the "warning→error" interactions among the interface components, where CC=Customer Connect, PEREST=Adapter, API=PERESTAPI and PE Server = f_rsp

7.1.2.1. Swagger Specifications

The following changes are required, for each POST, PATCH and/or DELETE API operation:

Add an Ignored-Warning tag (Camel case insensitive) to each request and response headers definitions.

The request header will store warning message IDs that are intended to be ignored in the SV server.

"parameters": [ ... { "required": false, "type": "string", "name": "Ignored-Warning", "in": "header", "description": "To store warning message IDs in comma separated string that will be ignored by the server" } ]

The response header will store the successfully ignored warning message IDs returned by the same API call. Note that, the current Open API Specification (3.0) does not permit to define common response headers for different response codes or different API operations. Users need to define the headers for each response individually. This Ignored-Warning tag will store a list of warning message IDs in comma separated string format.

"responses": { "201": { "description": "Created", "headers": { "Ignored-Warning": { "description": "To store warning message IDs in comma separated string of same API call that have been successfully ignored in server", "type": "string" } }, "schema": { "$ref": "#/definitions/Customer" } },

Update the Error definition description field with the correct usage purpose, i.e.: Error→@type: "Error" to indicate a normal aborted error message or "Warning" to indicate an SV server warning message.

"Error": { ... "properties": { ... "@type": { "type": "string", "description": "'Error' indicates that the error message is of server error message, 'Warning' indicates that the error message is of server warning message" } } }

7.2. Extensions

Non-core web applications (extensions) can be rendered in Customer Connect using iframes.

Icons must be assigned to the extensions. It is recommended to use icons that are not part of the core icons to distinguish the extensions.

Click on the extension to open the dialog box.

Note The URL is integrated into an iframe within the dialog box. The user can interact with other features of the Customer Connect while using the extensions.

The extension dialog box will remain open until it is closed. Click the Cancel button or press the Esc button on the keyboard to close the dialog box.

7.2.1. iframe Configuration

The extensions are displayed on the Customer Connect application based on the Profile And External Application Mapping and External Applications DA table configurations.

To configure the Profile And External Application Mapping DA table:

Search the Profile And External Application Mapping table.

Open the table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

In the Profile Name drop-down list, select the required profile.

Enter the URL. Full path to HTTP or HTTPS-based customer application URL.

Click the Tick Mark icon to save the changes.

To configure the External Applications DA table:

Search the External Applications table.

Open the table.

Click the Edit icon to edit the table.

Click the + icon to insert a new row to the table.

Enter the URL. Full path to HTTP or HTTPS-based customer application URL.

Note Must match the Profile And External Application Mapping DA table’s URL column value.

Enter the Title. Title of external application is displayed in the dialog box containing an iframe. It is also displayed as a tooltip when the user mouse hovers on the iframe icon.

Enter the Width. Window width of the Customer application.

Enter the Height. Window height of the Customer application.

In the CSS Unit drop-down list, select the required unit from the list. Unit for height and width. (Centimeters, Millimeters, Quarter-millimeters, Inches, Picas, Points, Pixels)

List of params that are passed to extensions from Customer Connect:

Param Name Data Type Available Context loginId Number Always Available loginName String Always Available profileName String Always Available customerNodeId Number Customer Context parentCustomerNodeId Number Customer Context rootCustomerNodeId Number Customer Context customerName String Customer Context primaryContactName String Customer Context customerType String Customer Context adminNumber String Customer Context subscriberId String Customer Context contactId Number Customer/Contact Context contactClassification String Customer/Contact Context previewSelectedCaseId Number Case Context workSelectedCaseId Number Case Context previewSelectedIssueId Number Issue Context workSelectedIssueId Number Issue Context customerTags String Array Customer Context authToken { expiryDate: string; authenticationToken: string; } rootProductOfferId String Service Context selectedBaseProductInstanceId String primaryServiceDetails { serviceId: string; name: string; displayName: string; status: string; networkName: string; } Service Context selectedServiceDetails { serviceId: string; name: string; displayName: string; status: string; networkName: string; } Service Context

7.2.2. User Access

Customer Connect will fetch the configuration via GET User REST API. The GET User REST API returns the extensions accessible to the operator as per the profile configured in the Profile And External Application Mapping DA Table. Each extension can be configured for different profiles in the DA table.

Example:

The user (a) with Profile1 has access to the extension URL1, URL2, and URL3. The same user (a) does not have access to URL4.

The user (b) with Profile2 has access to extension URL2 and URL4.

The user (c) with no profile configured in the DA Table, none of the extensions will be accessible.

Profile URL Accessible Profile1 URL1 Yes Profile1 URL2 Yes Profile1 URL3 Yes Profile2 URL2 Yes Profile2 URL4 Yes

7.2.3. Constraints and Limitations

No user session will be maintained for extensions.

Extensions can be accessed only from the CSR toolbar.

Only absolute units are supported for width and height.

Only HTTP or HTTPS-based URLs are supported.

The dialog box cannot be resized by the user.

Only icons released with Customer Connect are supported.

7.3. External Plugins Support

Customer Connect supports the external plugin modules developed by customers. To deploy external plugin modules into the application, Module Federation is used.

Module federation has two parts:

Shell Application (Customer Connect)

Federated Modules (Plugin Modules)

The external plugin modules are loaded into an extension point in the shell application.

Supported extension points:

Extension Point Support Angular Component Support Angular Module Support iFrame Content CSR Toolbar Yes It will be loaded in the main application area as a dynamic route. Yes It will be loaded inside a popup window. Yes It will be loaded inside a popup window. CSR Dashboard Yes Supports a single plugin and replaces the default dashboard. If multiple plugins are configured, the application will pick the first active plugin. Note If the external plugin fails to load, the application will display the default dashboard. Yes Supports multiple plugins. It will be displayed on the CSR dashboard as widgets. No Customer Dashboard No Yes Supports multiple plugins. No Checkout Yes If Multiple Angular modules are added as checkout plugins, an Additional Info tab is displayed. Click on different plugins to open the plugins. No No

7.3.1. Build Project and Libraries

The following table contains the details of the project, build steps, and artifacts required to deploy the external plugins.

Project Description Build Steps Artifacts Customer Connect project Main application /src folder Following npm commands can be executed to build different types of build targets: When releasing for the client: npm run build:server:context → builds the app with context (/web). When releasing for the development: npm run build:server:dev → builds the app with development configuration without any context. /dist/cmuplift sv-ui-base /library/sv-ui-base This library contains UI components. Execute npm command: npm run build-sv-ui-base /dist/sv-ui-base/sv-ui-base-2.0.0.tgz sv-plugin-models /library/sv-plugin-models This library contains interface definitions and DTOs required to build plugins. Execute npm command: npm run build-sv-plugin-models /dist/sv-plugin-models/sv-plugin-models-1.0.0.tgz sv-plugin-models API Documentation Generates documentation for sv-plugin-models library. Execute npm command: npm run doc:sv-dto-models /documentation/sv-dto-models

7.3.2. Setting up Plugin Development Environment

Prerequisites to setup plugin development environment:

Component Version Node.Js v14 npm v6 Angular CLI v12.2.11

Build Package Description cmuplift-rel-6.11.0.zip cmuplift build archive sv-plugin-models-0.0.1.tgz sv-plugin-models npm package sv-ui-base-0.0.1.tgz (Optional) sv-ui-base npm package: To use cmuplift base UI library widgets in the plugin.

Build the application to setup the plugin development environment.

To setup the plugin development environment:

Extract the cmuplift-rel-<version>.zip file to a folder.

Open the extracted folder.

Open the cmuplift folder.

Run the npm i install lite-server -g.

Run the lite-server. This action starts the server and loads the Customer Connect application.

7.3.3. Creating Plugin

Plugins can be created from the beginning or using demo plugin project files.

To create the plugin and deploy it to the Customer Connect application:

Check the Angular CLI version. It must be the latest version.

Type ng version in the CLI to view the current version.

Two options to create a plugin:

Creating plugin from the beginning -

Create a new project ng new <project name>.

Check the angular libraries version in package.json file (project folder). The version must be 12.2.11 or higher.

Delete the package-lock.json and node_modules folders.

Run the npm install.

Creating plugin using demo project files -

Clone the reference project files.

Go to module-federation-demo-plugin-apps → plugin-scaffolding

Rename the plugin.

Run the npm install.

Open the plugin project using a text editor.

Run the npm start — --port=4300.

Check if the demo web application starts in the port http://localhost:4300.

Add sv-plugin-models-<version>.tgz and sv-ui-base-<version>.tgz libraries to plugin project.

Run the npm install …​<path>/sv-plugin-models-<version>.tgz

Run the npm install …​<path>/sv-ui-base-<version>.tgz (optional).

Add Module Federation configurations to the plugin project.

Open the terminal from the project root.

Run the ng add @angular-architects/module-federation. This action will add required libraries and changes the module to the Federated module. It will also modify existing files and add webpack.config.js file to the workspace. The webpack.config.js file is used to add the configurations to transform the Module/Component to a plugin.

Note: Skip this step if the plugin project is created using the demo project files.

7.3.3.1. Adding Plugin Component

To add plugin component:

Open the plugin project folder.

Run the ng g m <module name>.

Example:

Create a component in the module.

Open the module folder.

Run the ng g c <component name>.

Example:

Export the component.

Import the module to the app module.

Add the functionality of the plugin into the component.

Update the ts, html, and scss files.

Add the plugin component to the app component and verify if the plugin component works.

7.3.3.2. Add Plugin Module

To add plugin module:

Open the plugin project folder.

Run the ng g m <module name> --routing.

Example:

Create a component in the module.

Open the module folder.

Run the ng g c <component name>.

Example:

Add a component to the routing module.

Import the module to the app module.

Add the functionality of the plugin into the component.

Update the ts, html, and scss files.

7.3.3.3. Build Plugin

To build plugin:

Modify ModuleFederationPlugin configuration in webpack.config.js.

Provide appropriate value to the name, alias, and point it to the plugin component ts file or plugin module ts file in the exposes attribute.

Example: Plugin Component

Example: Plugin Module

Note The version must be 12.2.11 or higher.

Open the plugin project folder.

Run the npm run build.

Example:

The compiled plugin will be displayed in the dist folder.

Note To auto-trigger the build for any change done to the plugin code, run the npm run watch .

Configure the plugins. For more information on configuring plugins, see Plugin Configurations.

7.3.4. Accessing Data inside Plugin

Using Module Federation, Angular Module or Angular Component can be exposed as a plugin. If the plugin is loaded inside the shell cmuplift application, the plugin will be able to access data within the context of the shell application through IPluginDataSandbox interface methods.

Depending on whether it’s an Angular Module or Angular Component, IPluginDataSandbox will be available to the components to add data and the template.

7.3.4.1. Angular Module as a Plugin

If the angular module is exposed as a plugin, it will be loaded as a dynamically created route inside the shell cmuplift application. The IPluginDataSandbox will be available as resolver data. The IPluginDataSandbox can be accessed through the router data.

Note The angular module plugin must have child routing defined and included in the main module.

Example: Routing module for dashboard plugin

import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { CsrDashboardComponent } from './csr-dashboard/csr-dashboard.component'; const routes: Routes = [ { path: '', component: CsrDashboardComponent, }, ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule], }) export class PluginDashboardRoutingModule {}

Include routing module as import to the main Module

import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { CsrDashboardComponent } from './csr-dashboard/csr-dashboard.component'; import { PluginDashboardRoutingModule } from './plugin-dashboard.routing.module'; import { ClarityModule } from '@clr/angular'; @NgModule({ declarations: [CsrDashboardComponent], imports: [CommonModule, ClarityModule, PluginDashboardRoutingModule], }) export class PluginDashboardModule {}

Access sandbox methods via router.snapshot.data inside the component

import { Component } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; import { filter, map, switchMap, tap } from 'rxjs/operators'; import { Observable } from 'rxjs'; import { CMCase, IPluginDataAuthSandbox, IPluginDataCsrCaseSandbox, IPluginDataSandbox, ListCriteria, SortOrder, } from 'sv-plugin-models'; @Component({ selector: 'app-csr-dashboard', templateUrl: './csr-dashboard.component.html', styleUrls: ['./csr-dashboard.component.scss'], }) export class CsrDashboardComponent { private sandbox: IPluginDataSandbox; private csrCaseSandbox: IPluginDataCsrCaseSandbox; private authSandbox: IPluginDataAuthSandbox; public cases$: Observable<CMCase[]>; public userName$: Observable<string>; constructor(private route: ActivatedRoute) { this.initializeSandboxes(); } initializeSandboxes(): void { const { sandbox } = this.route.snapshot.data; this.sandbox = sandbox; if (this.sandbox) { this.csrCaseSandbox = this.sandbox.getCsrCaseSandbox(); this.authSandbox = this.sandbox.getAuthSandbox(); } } ngOnInit(): void { let searchCriteria; let listCriteria: ListCriteria<any>; searchCriteria = { csrId: 0, retrievalLimit: '5', }; listCriteria = { searchCriteria, sortCriteria: { sortKey: 'created', sortOrder: SortOrder.DESC }, }; this.cases$ = this.authSandbox.getUserId().pipe( filter((d) => d > 0), switchMap((id) => { listCriteria = { ...listCriteria, searchCriteria: { ...listCriteria.searchCriteria, csrId: id }, }; return this.csrCaseSandbox.getCsrCaseRecentCases(listCriteria); }), map((f) => (f || []).filter((f) => !!f)), tap(console.log) ); this.userName$ = this.authSandbox.getUserName(); } }

Initialise sandboxes through route data

initializeSandboxes(): void { const { sandbox } = this.route.snapshot.data; this.sandbox = sandbox; if (this.sandbox) { this.csrCaseSandbox = this.sandbox.getCsrCaseSandbox(); this.authSandbox = this.sandbox.getAuthSandbox(); } }

7.3.4.2. Angular Component as a Plugin

If the single angular component is exposed as a plugin, the IPluginDataSandbox can be accessed by defining a public property name sandbox inside the component. When initialising the component shell application(cmuplift), it will initialise with the IPluginDataSandbox instance.

@Input() public set sandbox(sb: IPluginDataSandbox) { this.initializeSandbox(sb); }

Example component:

import { Component, Input, OnInit } from '@angular/core'; import { filter } from 'rxjs/operators'; import { IPluginDataAuthSandbox, IPluginDataSandbox } from 'sv-plugin-models'; @Component({ selector: 'app-loyalty-widget', templateUrl: './loyalty-widget.component.html', styleUrls: ['./loyalty-widget.component.scss'], }) export class LoyaltyWidgetComponent implements OnInit { private authSandbox: IPluginDataAuthSandbox; @Input() public set sandbox(sb: IPluginDataSandbox) { this.initializeSandbox(sb); } userName: string = ''; constructor() {} initializeSandbox(sb: IPluginDataSandbox): void { if (sb) { this.authSandbox = sb.getAuthSandbox(); } } ngOnInit(): void { this.authSandbox .getUserName() .pipe(filter((val) => !!val)) .subscribe((name) => { this.userName = name; }); } }

7.3.5. Plugin Configurations

After the creation of plugin, it must be configured to get loaded into the Customer Connect application.

To configure the plugin:

Copy the build plugin folder into path <cmuplift server directory>/plugins.

Update the config.json file in the path <cmuplift server directory>/plugins.

Enter the URL and Name.

URL must be relative path to the Plugin/remoteEntry.js file.

Name must be unique as defined in <plugin project root>/webpack.config.js file.

Name:

URL:

Configure the perestapi.EXTERNAL_APPLICATION list in Business & Administration Studio (BAS) application.

Login to the BAS application.

Open the perestapi.EXTERNAL_APPLICATION list.

Add new application name.

Save the details.

Configure the External Applications table in BAS.

Login to the BAS application.

Open the External Applications table.

Create new application entry and configure the plugin details.

7.3.6. Global Style Overrides

After the successful development of the plugin and integration with Customer Connect, the UI layout can be further customised to enhance the visual experience.

Plugin folder contains the styles-overrides.css file to which global styles can be applied to override the UI layouts.

Note Screens order of the widgets and their placement is important for application performance. Any override must be performed after thorough analysis.

Use Case

Problem:

The following customer dashboard screen contains three cards, Offers, Recommendations, and Sample Plugin, positioned at the bottom of the page.

Requirements: Need to rearrange the cards.

First - Sample Plugin

Second - Recommendation

Third - Offers

Solution:

Use <cmuplift-rel-package>/plugins/styles-overrides.css file to override global styles to customise the UI widgets according to the requirements.

.cust-dashboard-container li[class*='cd-plugin-'] { order: -5; } .cust-dashboard-container .cd-recommended-offer { order: -3; } .cust-dashboard-container .cd-next-best-offers{ order: -4; }

Save the changes and reload the app to view the results.

8. Product Configuration

The product catalogue maintains product offerings and product components and helps the service provider to sell them quickly and efficiently. For instructions on creating a TMF-compliant product catalogue of offers that can be explored and sold from Customer Connect, refer to the Product Catalog Configuration guide for more information.

8.1. Operations for Purchased Products

Purchased product operations can be fully or partially disabled based on the response of the customerServiceUpdateOp API. For building the API response as per need, a list of controllable operations is available in reference type Customer Service Operations. The CustomerServiceUpdateOp API is available to plugin business logic to disable specific operations on purchased product screens or make them entirely read-only.

The following is a list of scenarios where purchased product operations are disabled:

When the service contains a vacation suspension offer.

When the service contains any pending installation of an order, as per the existing functionality.

8.2. Configuration of Multiple Product Offers with Same Display Name

To enable configuration of multiple product offers with same display name:

Search the PROD_OFFER_DISPLAY_NAME_UNIQUE_ENABLED list.

Open PROD_OFFER_DISPLAY_NAME_UNIQUE_ENABLED list.

Click the Edit icon to edit the list.

Disable the Enabled? column for the reference code 1.

Click the Tick Mark icon to save the changes.

Note Offer having same display name is not supported when Enabled is Yes. If the Enabled? column for reference code 1 in the PROD_OFFER_DISPLAY_NAME_UNIQUE_ENABLED list is updated from No back to Yes, the project team needs to clean up the already created offers that have the same display name.

9. Configuring Order Task Framework

The Order Task Framework gives the ability to configure certain tasks to be executed on the Customer Connect UI through configuration.

9.1. Configuration for executing Tasks in Customer Connect

The primary DA that drives the configuration is perestapi.dOrderFramework. The entries from this DA are fetched through the API processFlowSpecification.

The main column details are for this DA listed below:

Column Details How to Configure Channel ( Mandatory ) The client channel (product) that will be using this configuration. Supported values from Reference Type perestapi.imp.CHANNEL_TYPE. For Customer Connect the value should be Customer Connect. Catalog ( Mandatory ) The product offer catalog. Supported values from Reference Type perestapi.imp.CATALOG. Market Offers: Standard configuration for product offer catalog. Service Specific Offers (Logical TLO): The parent market offer’s catalog should be used. Leaf Level Child Offers: The parent market offer’s catalog should be used. Category ( Mandatory ) The product offer category. Supported values from Reference Type perestapi.imp.CATEGORY. This applies to market offers, service specific offers (logical TLOs) and leaf level offers. The category is applied by setting the product offer tag on an offer. Market Offers: For market offers, setting a valid entry as a product offer tag on the concerned market offer. A category is only considered valid if it is present in the Derived Attribute perestapi.dCatalogCategory. Here only the categories that correspond to the current market offer’s catalog are considered valid. Service Specific Offer (Logical TLO): For logical TLOs a special type of category is required. This needs to be configured in PRODUCT_OFFER_TAGS with the code label having a prefix of CTG_WF_. Example: CTG_WF_BROADBAND A similar configuration with the same code label needs to be made in the Reference Type perestapi.imp.CATEGORY. Leaf Level Child Offers: Leaf level child offers can have one of the following supported product offer tags: CTG_ADDON CTG_VAS CTG_DEVICE or CTG_SMARTPHONE CTG_DEPOSIT CTG_TOPUP CTG_DISCOUNT CTG_SHARELIMIT Parent category The category of the parent market offer. Supported values from Reference Type perestapi.imp.CATEGORY. This applies to service specific offers (logical TLOs) and leaf level offers. Market Offers: Market Offers should not have a parent category. Service Specific Offer (Logical TLO): The parent Market Offer’s category should be used here. Leaf Level Child Offers: The parent Market Offer’s category should be used here. Order Type ( Mandatory ) Represents one of the supported order types: Alter Product Options Sales Order Update Product Details Equipment Swap Use the following entries based on order type: Sales Order: Sales Order Add Child Offer: Alter Product Options Change Plan: Alter Product Options Add Service: Alter Product Options Cancel Service: Update Product Details SIM Swap: Equipment Swap Change MSISDN: Equipment Swap Suspend Service: Update Product Details Reactivate Service: Update Product Details Service Attributes Update : Alter Product Options Order Sub Type Represents one of the supported order sub-types: Add Child Offer Change Plan Cancel Service Add Service Change to Postpaid Change to Prepaid SIM Swap Change MSISDN Suspend Service Reactivate Service Service Attributes Update Use the following entries based on order type: Sales Order: No value should be configured. Add Child Offer: Add Child Offer Change Plan: Change Plan Cancel Service: Cancel Service Add Service: Add Service Change to Postpaid: Change from Prepaid Service to Postpaid. Change to Prepaid: Change from Postpaid Service to Prepaid. SIM Swap: SIM Swap Change MSISDN : Change MSISDN Suspend Service: Suspend Service Reactivate Service: Reactivate Service Service Attributes Update: Service Attributes Update Reason None Use the following entries based on order type: Sales Order: No value should be configured. The following actions are performed using one of the provided reason codes or the value "Any": Add Child Offer (Mandatory) Change Plan (Mandatory) Cancel Service (Mandatory) Add Service (Mandatory) SIM Swap (Mandatory) Change MSISDN (Mandatory) Suspend Service (Mandatory) Reactivate Service (Mandatory) Service Attributes Update (Mandatory) Order Stage ( Mandatory ) The order stage at which to trigger the task. Supported values from Reference Type perestapi.imp.ORDER_STAGE. The following order stages are supported: Add Child Offer Change Plan Proceed to Configuration Proceed to Cart Edit Order SIM Details Complete Order Checkout Cancel Subscription Continue for Suspend Continue for Resume Cart - Next Payment - Payment Confirm Review - Confirm Payment Service Attribute - Continue Sequence ( Mandatory ) The sequence in the task needs to be executed for the same process specification. Multiple tasks can be configured for the values in all the above columns by adding sequence numbers to each task. This order is respected in Customer Connect while invoking tasks. Task ( Mandatory ) The task to execute. Supported values from Reference Type perestapi.imp.TASK_TYPE. Select from the following supported tasks: OTP Validation: Used to trigger an OTP validation which only allows to proceed on successful validation. SIM Delivery: A task used to enable the delivery option checkbox for eligible offers (TLOs and Logical TLOs that have CTG_DELIVERY offer tag). Can only be configured with order stage SIM Details. Credit Check: A task used to check the creditworthiness of the user by triggering creditCheck API and only allows to proceed if the customer is creditworthy. This is supported in Add Child Offer and Change Plan flows. For Add Child Offer, configure Order Type as Alter Product Options, Order Sub Type as Add Child Offer. To trigger the credit check API at Add Child Offer stage, Order Stage should be Add Child Offer and to trigger at Proceed to Cart Stage, Order Stage should be Proceed to Cart. For Change Plan, configure Order Type as Alter Product Options, Order Sub Type as Change Plan. To trigger the credit check API at the Proceed to Configuration stage, Order Stage should be Proceed to Configuration and to trigger at the Proceed to Cart Stage, Order Stage should be Proceed to Cart. Future Termination: This enables future termination for the service while doing Cancel Service. The service will be terminated only at the end of the bill cycle or balance expiry based on the service. Contract: Enables the collection of a Contract Document for offers that support Contracts during the order flow by providing a screen to upload documents against the offer. Currently support for this screen is limited to the “Checkout” Order Stage. Migration Assessment: A task used to check whether the migration from one plan to another is allowed or not. This is only supported in Proceed to Configuration stage for Change Plan, Change to Postpaid and Change to Prepaid Order Sub Types. Description ( Mandatory ) The task description. A descriptive name for the task.

9.2. Different Order Stages

Add Child Offer: This applies when triggering an Add Child Offer action in customer services. The task will be triggered after selection of the reason code.

Change Plan: This applies when triggering a Change Plan action in customer services. The task will be triggered after selection of the reason code.

Supported flow:

Not Supported flow:

Proceed to Configuration: This applies after selecting an offer, on proceeding for configuration.

Change Plan:

Sales Order:

Change to Prepaid:

Change to Postpaid:

Proceed to Cart: This applies when proceeding to the cart (Proceed to Cart or Proceed to Checkout) after order configuration.

Edit Order: This applies when attempting to edit an order.

SIM Details: This order stage is used to enable Delivery checkbox for eligible offers (TLOs and Logical TLOs that have CTG_DELIVERY offer tag) in order config. If Order Task Framework is active, then the Delivery checkbox will only be visible if the order stage is SIM Details and the task is SIM Delivery.

Complete Order: This applies when trying to submit an order.

Checkout: This stage impacts the presentation of the screens during the “Checkout” module, such as controlling whether the “Contracts” tab appears to capture contract documents prior to completing the order.

Suspend Service: This applies when triggering a Change to Suspended in customer services. The task will be triggered after selecting the reason code.

Reactivate Service: This applies when triggering a Change to Active in customer services. The task will be triggered after selecting the reason code.

SIM Swap: This applies when triggering the Add to Cart action. The task will be triggered after selecting the SIM and reason code.

Note In the SIM Swap flow, during the SIM Details stage, it is important to remember that the Reason Code is not required for the SIM Delivery Checkbox. This is because, in the context of a SIM swap, the reason for SIM delivery is not necessary.

Change MSISDN: This applies when triggering the Add to Cart action. The task will be triggered after selecting the MSISDN.

Cancel Subscription: This applies when attempting to do Cancel Subscription.

Note The checkout order task is enable only for specific flows, such as Alter Order, Change Plan, Sales Order, Cancel Subscription, Change SIM, and Change MSISDN.

Cart - Next: This applies when attempting to click the Next button.

Payment - Payment Confirm: This applies when attempting to click an Confirm button.

Review - Confirm Payment: This applies when attempting to click the Confirm Payment button.

Service Attribute - Continue: This applies when attempting to update the service attribute. This will be triggered after selecting the reason code for the update.

9.3. Meaning of Special Value Types

Undefined: An entry with empty has a special meaning. This means that the concerned cell has no value. Hence it cannot match with any value. Example: if the reason code is Undefined in Add Child Offer in this DA, then creating an Add Child Offer with reason code (mandatory) on Customer Connect will not match with this row.

Any: This is a special value that is only supported by the column Reason Code. Configuring a value of Any in reason code in this DA means that the row will match orders with all valid reason codes. Any will match all values other than Undefined.

10. References

For further information about Customer Connect, refer to the following guides:

User Guide for Customer Connect

Installation and Post-Installation Guide for Customer Connect

Last updated 2024-08-21 05:17:44 +0550